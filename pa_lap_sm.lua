-- ex: set ro:
-- DO NOT EDIT.
-- generated by smc (http://smc.sourceforge.net/)
-- from file : pa_lap.sm

local error = error
local pcall = pcall
local tostring = tostring
local strformat = require 'string'.format

local statemap = require 'statemap'

_ENV = nil

local LAPState = statemap.State.class()

local function _empty ()
end
LAPState.Entry = _empty
LAPState.Exit = _empty

local function _default (self, fsm)
    self:Default(fsm)
end
LAPState.Assign = _default
LAPState.Depracate = _default
LAPState.Done = _default
LAPState.Error = _default
LAPState.Timeout = _default
LAPState.UnInit = _default
LAPState.Unassign = _default

function LAPState:Default (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("TRANSITION   : Default\n")
    end
    local msg = strformat("Undefined Transition\nState: %s\nTransition: %s\n",
                          fsm:getState().name,
                          fsm.transition)
    error(msg)
end

local LAP = {}

LAP.Default = LAPState:new('LAP.Default', -1)

function LAP.Default:Error (fsm, s)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Default\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Default:Error(s=" .. tostring(s) .. ")\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:error(s)
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Default:Error(s=" .. tostring(s) .. ")\n")
    end
    fsm:setState(LAP.Error)
    fsm:getState():Entry(fsm)
end

function LAP.Default:UnInit (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Default\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Default:UnInit()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Default:UnInit()\n")
    end
    fsm:setState(LAP.FinishedNoState)
    fsm:getState():Entry(fsm)
end

function LAP.Default:Default (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Default\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Default:Default()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Default:Default()\n")
    end
end

LAP.Init = LAP.Default:new('LAP.Init', 0)

function LAP.Init:Assign (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Init\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Init:Assign()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Init:Assign()\n")
    end
    fsm:setState(LAP.Assigning)
    fsm:getState():Entry(fsm)
end

LAP.Assigning = LAP.Default:new('LAP.Assigning', 1)

function LAP.Assigning:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:do_assign()
end

function LAP.Assigning:Depracate (fsm)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Assigning\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Assigning:Depracate()\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:stop_assign()
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Assigning:Depracate()\n")
    end
    fsm:setState(LAP.Depracating)
    fsm:getState():Entry(fsm)
end

function LAP.Assigning:Done (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Assigning\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Assigning:Done()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Assigning:Done()\n")
    end
    fsm:setState(LAP.Live)
    fsm:getState():Entry(fsm)
end

function LAP.Assigning:Unassign (fsm)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Assigning\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Assigning:Unassign()\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:stop_assign()
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Assigning:Unassign()\n")
    end
    fsm:setState(LAP.Unassigning)
    fsm:getState():Entry(fsm)
end

LAP.Unassigning = LAP.Default:new('LAP.Unassigning', 2)

function LAP.Unassigning:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:do_unassign()
end

function LAP.Unassigning:Assign (fsm)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Unassigning\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Unassigning:Assign()\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:stop_unassign()
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Unassigning:Assign()\n")
    end
    fsm:setState(LAP.Assigning)
    fsm:getState():Entry(fsm)
end

function LAP.Unassigning:Depracate (fsm)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Unassigning\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Unassigning:Depracate()\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:stop_unassign()
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Unassigning:Depracate()\n")
    end
    fsm:setState(LAP.Depracating)
    fsm:getState():Entry(fsm)
end

function LAP.Unassigning:Done (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Unassigning\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Unassigning:Done()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Unassigning:Done()\n")
    end
    fsm:setState(LAP.Standby)
    fsm:getState():Entry(fsm)
end

LAP.Depracating = LAP.Default:new('LAP.Depracating', 3)

function LAP.Depracating:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:do_depracate()
end

function LAP.Depracating:Assign (fsm)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Depracating\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Depracating:Assign()\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:stop_depracate()
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Depracating:Assign()\n")
    end
    fsm:setState(LAP.Assigning)
    fsm:getState():Entry(fsm)
end

function LAP.Depracating:Done (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Depracating\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Depracating:Done()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Depracating:Done()\n")
    end
    fsm:setState(LAP.Zombie)
    fsm:getState():Entry(fsm)
end

function LAP.Depracating:Unassign (fsm)
    local ctxt = fsm.owner
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Depracating\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Depracating:Unassign()\n")
    end
    fsm:clearState()
    local r, msg = pcall(
        function ()
            ctxt:stop_depracate()
        end
    )
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Depracating:Unassign()\n")
    end
    fsm:setState(LAP.Unassigning)
    fsm:getState():Entry(fsm)
end

LAP.Live = LAP.Default:new('LAP.Live', 4)

function LAP.Live:Depracate (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Live\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Live:Depracate()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Live:Depracate()\n")
    end
    fsm:setState(LAP.Depracating)
    fsm:getState():Entry(fsm)
end

function LAP.Live:Unassign (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Live\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Live:Unassign()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Live:Unassign()\n")
    end
    fsm:setState(LAP.Unassigning)
    fsm:getState():Entry(fsm)
end

LAP.Standby = LAP.Default:new('LAP.Standby', 5)

function LAP.Standby:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:start_depracate_timeout()
end

function LAP.Standby:Exit (fsm)
    local ctxt = fsm.owner
    ctxt:stop_depracate_timeout()
end

function LAP.Standby:Assign (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Standby\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Standby:Assign()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Standby:Assign()\n")
    end
    fsm:setState(LAP.Assigning)
    fsm:getState():Entry(fsm)
end

function LAP.Standby:Depracate (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Standby\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Standby:Depracate()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Standby:Depracate()\n")
    end
    fsm:setState(LAP.Depracating)
    fsm:getState():Entry(fsm)
end

function LAP.Standby:Timeout (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Standby\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Standby:Timeout()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Standby:Timeout()\n")
    end
    fsm:setState(LAP.Depracating)
    fsm:getState():Entry(fsm)
end

LAP.Zombie = LAP.Default:new('LAP.Zombie', 6)

function LAP.Zombie:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:start_expire_timeout()
end

function LAP.Zombie:Exit (fsm)
    local ctxt = fsm.owner
    ctxt:stop_expire_timeout()
end

function LAP.Zombie:Assign (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Zombie\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Zombie:Assign()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Zombie:Assign()\n")
    end
    fsm:setState(LAP.Assigning)
    fsm:getState():Entry(fsm)
end

function LAP.Zombie:Timeout (fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("LEAVING STATE   : LAP.Zombie\n")
    end
    fsm:getState():Exit(fsm)
    if fsm.debugFlag then
        fsm.debugStream:write("ENTER TRANSITION: LAP.Zombie:Timeout()\n")
    end
    if fsm.debugFlag then
        fsm.debugStream:write("EXIT TRANSITION : LAP.Zombie:Timeout()\n")
    end
    fsm:setState(LAP.Finish)
    fsm:getState():Entry(fsm)
end

LAP.Error = LAP.Default:new('LAP.Error', 7)

function LAP.Error:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:done()
end

LAP.Finish = LAP.Default:new('LAP.Finish', 8)

function LAP.Finish:Entry (fsm)
    local ctxt = fsm.owner
    ctxt:done()
end

LAP.FinishedNoState = LAP.Default:new('LAP.FinishedNoState', 9)

local pa_lapContext = statemap.FSMContext.class()

function pa_lapContext:_init ()
    self:setState(LAP.Init)
end

function pa_lapContext:Assign ()
    self.transition = 'Assign'
    self:getState():Assign(self)
    self.transition = nil
end

function pa_lapContext:Depracate ()
    self.transition = 'Depracate'
    self:getState():Depracate(self)
    self.transition = nil
end

function pa_lapContext:Done ()
    self.transition = 'Done'
    self:getState():Done(self)
    self.transition = nil
end

function pa_lapContext:Error (...)
    self.transition = 'Error'
    self:getState():Error(self, ...)
    self.transition = nil
end

function pa_lapContext:Timeout ()
    self.transition = 'Timeout'
    self:getState():Timeout(self)
    self.transition = nil
end

function pa_lapContext:UnInit ()
    self.transition = 'UnInit'
    self:getState():UnInit(self)
    self.transition = nil
end

function pa_lapContext:Unassign ()
    self.transition = 'Unassign'
    self:getState():Unassign(self)
    self.transition = nil
end

function pa_lapContext:enterStartState ()
    self:getState():Entry(self)
end

return 
pa_lapContext
-- Local variables:
--  buffer-read-only: t
-- End:
