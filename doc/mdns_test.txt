-*- outline -*-

* draft-cheshire-dnsext-multicastdns-15 MUST/SHOULDs/MUST NOTs [182]

** s2: conventions and terminology (wtf) [2]

+[1] MUST probe to verify that no other Responder already claims ownership
of that set, as described in Section 8.1 "Probing"

~[2] cooperating Responders MUST give answers containing identical rdata for
these records

** s3: multicast DNS names [3]

![1] (in case of naming conflict) If this happens, the computer (or its
   human user) MUST cease using the name

![2] SHOULD attempt to allocate a new unique name for use on that link

![3] Any DNS query for a name ending with ".local." MUST be sent to the mDNS
   multicast address 224.0.0.251 (or its IPv6 equivalent FF02::FB)

** s4: reverse address mapping [2]

![1] IPv4 reverse address mapping - send queries for 254.169.in-addr.arpa
(or IPv6 ll) to 224.0.0.251

![2] IPv6 reverse mapping ==> ff02::fb

(Intentionally skipped because the reverse mappings are for linklocals, and
we filter them)

** s5: querying [21]

.. should implement querying for real

-[1] responder MUST implement DNS querier

-[2] (unicast, non-mdns) .. these queries MUST NOT be sent using UDP source
   port 5353, since using UDP source port 5353 signals the presence of a
   fully-compliant Multicast DNS Querier

-[3,4,5] (continuous mdns querying) Therefore, when retransmitting mDNS
   queries to implement this kind of continuous monitoring, the interval
   between the first two queries MUST be at least one second, the intervals
   between successive queries MUST increase by at least a factor of two,
   and the querier MUST implement Known-Answer Suppression

-[6] a Multicast DNS Querier SHOULD also delay the first query of the series
   by a randomly-chosen amount in the range 20- 120ms.

-[7] When a Multicast DNS Querier receives an answer, the answer contains a
   TTL value that indicates for how many seconds this answer is valid.
   After this interval has passed, the answer will no longer be valid and
   SHOULD be deleted from the cache

-[8] Before this time is reached, a Multicast DNS Querier which has local
   clients with an active interest in the state of that record (e.g. a
   network browsing window displaying a list of discovered services to the
   user) SHOULD re-issue its query to determine whether the record is still
   valid.

(.. not caps-should; 80, 85, 90, 95% sending +0-2%)

-[9] A Multicast DNS Querier MUST NOT perform this cache maintenance for
   records for which it has no local clients with an active interest.

-[10] An additional efficiency optimization SHOULD be performed when a
   Multicast DNS response is received containing a unique answer (as
   indicated by the cache-flush bit being set, described in
   Section 10.2, "Announcements to Flush Outdated Cache Entries"). In
   this case, there is no need for the querier to continue issuing a
   stream of queries with exponentially-increasing intervals, since the
   receipt of a unique answer is a good indication that no other answers
   will be forthcoming. In this case, the Multicast DNS Querier SHOULD
   plan to issue its next query for this record at 80-82% of the
   record's TTL, as described above.


-[11,12] A compliant Multicast DNS Querier, which implements the rules
   specified in this document, MUST send its Multicast DNS Queries from
   UDP source port 5353 (the well-known port assigned to mDNS), and MUST
   listen for Multicast DNS Replies sent to UDP destination port 5353 at
   the mDNS multicast address (224.0.0.251 and/or its IPv6 equivalent
   FF02::FB).

-[13] A Multicast DNS Querier sending its initial batch of questions
   immediately on wake from sleep or interface activation SHOULD set the
   "QU" bit in those questions.

-[14,15] When a question is retransmitted (as described in Section 5.2) the
   "QU" bit SHOULD NOT be set in subsequent retransmissions of that
   question. Subsequent retransmissions SHOULD be usual "QM" questions.

-[16] In addition, the "QU" bit SHOULD be set only for questions that are
   active and ready to be sent the moment of wake from sleep or interface
   activation.

-[17] New questions created by local clients afterwards should be treated as
   normal "QM" questions and SHOULD NOT have the "QU" bit set on the first
   question of the series.

+[18] When receiving a question with the "unicast response" bit set, a
   Responder SHOULD usually respond with a unicast packet directed back to
   the querier.

+[19] However, if the Responder has not multicast that record recently
   (within one quarter of its TTL), then the Responder SHOULD instead
   multicast the response so as to keep all the peer caches up to date, and
   to permit passive conflict detection.

+[20] When a Multicast DNS Responder receives a query via direct unicast, it
   SHOULD respond as it would for a "QU" query, as described above in
   Section 5.4

![21] Responders SHOULD check that the source address in the query packet
   matches the local subnet for that link (or, in the case of IPv6, the
   source address has an on-link prefix) and silently ignore the packet if
   not.


** s6: responding [49]

![1] A Multicast DNS Responder MUST NOT place records from its cache, which
   have been learned from other Responders on the network, in the Resource
   Record Sections of outgoing response packets.

.. impossible to unit test (negative proof); we don't do this, though

+[2] The determination of whether a given record answers a given question is
   done using the standard DNS rules: The record name must match the
   question name, the record rrtype must match the question qtype unless
   the qtype is "ANY" (255) or the rrtype is "CNAME" (5), and the record
   rrclass must match the question qclass unless the qclass is "ANY"
   (255). As with unicast DNS, generally only DNS class 1 ("Internet") is
   used, but should client software use classes other than 1 the matching
   rules described above MUST be used.

[3] A Multicast DNS Responder MUST only respond when it has a positive
   non-null response to send, or it authoritatively knows that a particular
   record does not exist.

[4] For unique records, where the host has already established sole
   ownership of the name, it MUST return negative answers to queries for
   records that it knows not to exist.

[5] For example, a host with no IPv6 address, that has claimed sole
   ownership of the name "host.local." for all rrtypes, MUST respond to
   AAAA queries for "host.local." by sending a negative answer indicating
   that no AAAA records exist for that name.

[6] For shared records, which are owned by no single host, the nonexistence
   of a given record is ascertained by the failure of any machine to
   respond to the Multicast DNS query, not by any explicit negative
   response. NXDOMAIN and other error responses MUST NOT be sent.

[7] Multicast DNS Responses MUST NOT contain any questions in the Question
   Section.

[8] Any questions in the Question Section of a received Multicast DNS
   Response MUST be silently ignored.

[9] A Multicast DNS Responder on Ethernet [IEEE.802.3] and similar shared
   multiple access networks SHOULD have the capability of delaying its
   responses by up to 500ms

[10,11] In the case where a Multicast DNS Responder has good reason to
   believe that it will be the only Responder on the link that will send a
   response (i.e. because it is able to answer every question in the query
   packet, and for all of those answer records it has previously verified
   that the name, rrtype and rrclass are unique on the link) it SHOULD NOT
   impose any random delay before responding, and SHOULD normally generate
   its response within at most 10ms.

[12] In any case where there may be multiple responses, such as queries
   where the answer is a member of a shared resource record set, each
   Responder SHOULD delay its response by a random amount of time selected
   with uniform random distribution in the range 20-120ms

[13] In the case where the query has the TC (truncated) bit set, indicating
   that subsequent Known-Answer packets will follow, Responders SHOULD
   delay their responses by a random amount of time selected with uniform
   random distribution in the range 400-500ms, to allow enough time for all
   the Known-Answer packets to arrive, as described in Section 7.2
   "Multi-Packet Known-Answer Suppression".

??? WTF, how does this work with packet reordering.. how does one identify
whole query?


[14] The source UDP port in all Multicast DNS Responses MUST be 5353 (the
   well-known port assigned to mDNS). 

[15] Multicast DNS implementations MUST silently ignore any Multicast DNS
   Responses they receive where the source UDP port is not 5353.


[16, 17] The destination UDP port in all Multicast DNS Responses MUST be
   5353 and the destination address MUST be the multicast address
   224.0.0.251 or its IPv6 equivalent FF02::FB, except when generating a
   reply to a query which explicitly requested a unicast response:

[18] Except for these three specific cases, responses MUST NOT be sent via
   unicast, because then the "Passive Observation of Failures" mechanisms
   described in Section 10.5 would not work correctly.  (the cases being,
   unicast response bit, legacy query, direct unicast query)

[19,20] A Multicast DNS Querier MUST only accept unicast responses if they
   answer a recently-sent query (e.g. sent within the last two seconds)
   that explicitly requested unicast responses. A Multicast DNS Querier
   MUST silently ignore all other unicast responses.

[21] To protect the network against excessive packet flooding due to
   software bugs or malicious attack, a Multicast DNS Responder MUST NOT
   (except in the one special case of answering probe queries) multicast a
   record on a given interface until at least one second has elapsed since
   the last time that record was multicast on that particular interface.

[22] In the special case of answering probe queries, because of the limited
   time before the probing host will make its decision about whether or not
   to use the name, a Multicast DNS Responder MUST respond quickly. (250ms
   cooldown here)


[23] Any time a Responder receives a query for a name for which it has
   verified exclusive ownership, for a type for which that name has no
   records, the Responder MUST (except as allowed in (a) below) respond
   asserting the nonexistence of that record using a DNS NSEC record
   [RFC4034].

[24] All compliant Multicast DNS implementations MUST at least correctly
   generate and parse the restricted DNS NSEC record format described
   below: 
 (next domain name = own name; type bitmap block # 0, block length 1-32,
   bit data 1-32 bytes, as indicated by length byte)

[25, 26] if a Multicast DNS Responder were to have records with rrtypes
   above 255, it MUST NOT generate these restricted-form NSEC records for
   those names. In such cases a Multicast DNS Responder MUST either (a)
   emit no NSEC record for that name, or (b) emit a full NSEC record
   containing the appropriate Type Bit Map block(s) with the correct bits
   set for all the record types that exist.

[27] If a Multicast DNS implementation receives an NSEC record where the
   'Next Domain Name' field is not the record's own name, then the
   implementation SHOULD ignore the 'Next Domain Name' field and process
   the remainder of the NSEC record as usual.

[28] In Multicast DNS the 'Next Domain Name' field is not currently used,
   but it could be used in a future version of this protocol, which is why
   a Multicast DNS implementation MUST NOT reject or ignore an NSEC record
   it receives just because it finds an unexpected value in the 'Next
   Domain Name' field.

[29] A Multicast DNS implementation MUST NOT ignore an entire packet just
   because that packet contains one or more NSEC record(s) that the
   Multicast DNS implementation cannot parse.


[30] To help differentiate these synthesized NSEC records (generated
   programmatically on-the-fly) from conventional Unicast DNS NSEC records
   (which actually exist in a signed DNS zone) the synthesized Multicast
   DNS NSEC records MUST NOT have the 'NSEC' bit set in the Type Bit Map,
   whereas conventional Unicast DNS NSEC records do have the 'NSEC' bit
   set.


[31] The TTL of the NSEC record indicates the intended lifetime of the
   negative cache entry. In general, the TTL given for an NSEC record
   SHOULD be the same as the TTL that the record would have had, had it
   existed. For example, the TTL for address records in Multicast DNS is
   typically 120 seconds (see Section 10) so the negative cache lifetime
   for an address record that does not exist should also be 120 seconds.

[32] A Responder MUST only generate negative responses to queries for which
   it has legitimate ownership of the name/rrtype/rrclass in question, and
   can legitimately assert that no record with that name/ rrtype/rrclass
   exists.

[33,34] When a Multicast DNS Responder sends a Multicast DNS Response
   message containing its own address records, it MUST include all
   addresses that are valid on the interface on which it is sending the
   message, and MUST NOT include addresses that are not valid on that
   interface (such as addresses that may be configured on the host's other
   interfaces)

[35] When a Multicast DNS Responder places an IPv4 or IPv6 address record
   (rrtype "A" or "AAAA") into a response packet, it SHOULD also place any
   records of the other address type with the same name into the additional
   section, if there is space in the packet.

[36] In the event that a device has only IPv4 addresses but no IPv6
   addresses, or vice versa, then the appropriate NSEC record SHOULD be
   placed into the additional section, so that queriers can know with
   certainty that the device has no addresses of that kind.

[37] Some Multicast DNS Responders treat a physical interface with both
   IPv4 and IPv6 address as a single interface with two addresses. Other
   Multicast DNS Responders may treat this case as logically two
   interfaces, (one with one or more IPv4 addresses, and the other with one
   or more IPv6 addresses) but Responders that operate this way MUST NOT
   put the corresponding automatic NSEC records in replies they send
   (i.e. a negative IPv4 assertion in their IPv6 responses, and a negative
   IPv6 assertion in their IPv4 responses) because this would cause
   incorrect operation in Responders on the network that work the former
   way.

[38] Multicast DNS Responders MUST correctly handle DNS query packets
   containing more than one question, by answering any or all of the
   questions to which they have answers.

[39] .. answers SHOULD be randomly delayed in the range 20-120ms, or 400-
   500ms if the TC (truncated) bit is set

[40] When possible, a Responder SHOULD, for the sake of network efficiency,
   aggregate as many responses as possible into a single Multicast DNS
   response packet.

[41] For example, when a Responder has several responses it plans to send,
   each delayed by a different interval, then earlier responses SHOULD be
   delayed by up to an additional 500ms if that will permit them to be
   aggregated with other responses scheduled to go out a little later.

[42] When responding to queries using qtype "ANY" (255) and/or qclass "ANY"
   (255), a Multicast DNS Responder MUST respond with *ALL* of its records
   that match the query.

[43] When responding to queries using qtype "ANY" (255) and/or qclass "ANY"
   (255), a Multicast DNS Responder MUST respond with *ALL* of its records
   that match the query.

[44] (when observing multicast) (in case of conflict) o If A's resource
   record is intended to be a member of a unique resource record set owned
   solely by that Responder, then this is a conflict and MUST be handled as
   described in Section 9 "Conflict Resolution".

[45] (when observing multicast) o If the TTL of B's resource record given
   in the packet is less than half the true TTL from A's point of view,
   then A MUST mark its record to be announced via multicast.

*** legacy unicast responses

[46] If the source UDP port in a received Multicast DNS Query is not port
   5353, this indicates that the Querier originating the query is a simple
   resolver such as described in Section 5.1 "One-Shot Multicast DNS
   Queries", which does not fully implement all of Multicast DNS. In this
   case, the Multicast DNS Responder MUST send a UDP response directly back
   to the Querier, via unicast, to the query packet's source IP address and
   port.

[47,48] This unicast response MUST be a conventional unicast response as
   would be generated by a conventional unicast DNS server; for example, it
   MUST repeat the query ID and the question given in the query packet.

[49] In addition, the "cache-flush" bit described in Section 10.2
   "Announcements to Flush Outdated Cache Entries" MUST NOT be set in
   legacy unicast responses.


** s7: traffic reduction [10]

[1] A Multicast DNS Responder MUST NOT answer a Multicast DNS Query if the
   answer it would give is already included in the Answer Section with an
   RR TTL at least half the correct value.

[2] If the RR TTL of the answer as given in the Answer Section is less than
   half of the true RR TTL as known by the Multicast DNS Responder, the
   Responder MUST send an answer so as to update the Querier's cache before
   the record becomes in danger of expiration.

[3] a Multicast DNS Querier SHOULD NOT include records in the Known-Answer
   list whose remaining TTL is less than half their original TTL.

[4] A Multicast DNS Querier MUST NOT cache resource records observed in the
   Known-Answer Section of other Multicast DNS Queries.

*** multi-packet KAS

[5] (too big) It MUST then set the TC (Truncated) bit in the header before
   sending the Query.

[6] It (.. sender) MUST then immediately follow the packet with another
   query packet containing no questions, and as many more Known-Answer
   records as will fit.  (Xn, and set TC, while too full)

[7] If the Responder sees any of its answers listed in the Known-Answer
   lists of subsequent packets from the querying host, it MUST delete that
   answer from the list of answers it is planning to give (provided that no
   other host on the network has also issued a query for that record and is
   waiting to receive an answer).

[8] If the Responder receives additional Known-Answer packets with the TC
   bit set, it SHOULD extend the delay as necessary to ensure a pause of
   400-500ms after the last such packet before it sends its answer.

*** DQS

[9] If a host is planning to transmit (or retransmit) a query, and it sees
   another host on the network send a QM query containing the same
   question, and the Known-Answer Section of that query does not contain
   any records which this host would not also put in its own Known- Answer
   Section, then this host SHOULD treat its own query as having been sent.

*** DAS

[10] If a host is planning to send an answer, and it sees another host on
   the network send a response packet containing the same answer record,
   and the TTL in that record is not less than the TTL this host would have
   given, then this host SHOULD treat its own answer as having been sent,
   and not also send an identical answer itself.


** s8: probing and announcing on startup [24]

[1] Whenever a Multicast DNS Responder starts up, wakes up from sleep,
   receives an indication of a network interface "Link Change" event, or
   has any other reason to believe that its network connectivity may have
   changed in some relevant way, it MUST perform the two startup steps
   below: Probing (Section 8.1) and Announcing (Section 8.3).

*** probing

[2] The first startup step is that for all those resource records that a
   Multicast DNS Responder desires to be unique on the local link, it MUST
   send a Multicast DNS Query asking for those resource records, to see if
   any of them are already in use.

[3] All Probe Queries SHOULD be done using the desired resource record name
   and class (usually class 1, "Internet"), and query type "ANY" (255), to
   elicit answers for all types of records with that name.

[4] When sending probe queries, a host MUST NOT consult its cache for
   potential answers.

[5] .. when a device receives a probe query for a name that it is currently
   using it SHOULD generate its response to defend that name immediately
   and send it as quickly as possible.

[6] Because of the mDNS multicast rate limiting rules, the probes SHOULD be
   sent as "QU" questions with the "unicast response" bit set, to allow a
   defending host to respond immediately via unicast, instead of
   potentially having to wait before replying via multicast.

[7,8] If during probing, from the time the first probe packet is sent until
   250ms after the third probe, any conflicting Multicast DNS response is
   received, then the probing host MUST defer to the existing host, and
   SHOULD choose new names for some or all of its resource records as
   appropriate.

[9] Apparently conflicting Multicast DNS responses received *before* the
   first probe packet is sent MUST be silently ignored.

[10] In the case of a host probing using query type "ANY" as recommended
   above, any answer containing a record with that name, of any type, MUST
   be considered a conflicting response and handled accordingly.

[11] If fifteen conflicts occur within any ten-second period, then the host
   MUST wait at least five seconds before each successive additional probe
   attempt.

[12] If a Responder knows by other means that its unique resource record
   set name, rrtype and rrclass cannot already be in use by any other
   Responder on the network, then it SHOULD skip the probing step for that
   resource record set.

[13] Similarly, if a Responder is acting as a proxy, taking over from
   another Multicast DNS Responder that has already verified the uniqueness
   of the record, then the proxy SHOULD NOT repeat the probing step for
   those records.


[14] (in tiebreaking) In the case of resource records containing rdata that
   is subject to name compression [RFC1035], the names MUST be uncompressed
   before comparison.

*** announcing

[15] The second startup step is that the Multicast DNS Responder MUST send
   an unsolicited Multicast DNS Response containing, in the Answer Section,
   all of its newly registered resource records (both shared records, and
   unique records that have completed the probing step).

[16] The Multicast DNS Responder MUST send at least two unsolicited
   responses, one second apart.


[17] A Multicast DNS Responder MUST NOT send announcements in the absence
   of information that its network connectivity may have changed in some
   relevant way.

[18] In particular, a Multicast DNS Responder MUST NOT send regular
   periodic announcements as a matter of course.


[19] Whenever a Multicast DNS Responder receives any Multicast DNS response
   (solicited or otherwise) containing a conflicting resource record, the
   conflict MUST be resolved as described in Section 9 "Conflict
   Resolution".

*** updating

[20] At any time, if the rdata of any of a host's Multicast DNS records
   changes, the host MUST repeat the Announcing step described above to
   update neighboring caches.

[21] For example, if any of a host's IP addresses change, it MUST
   re-announce those address records.

[22] In the case of shared records, a host MUST send a "goodbye"
   announcement with RR TTL zero (see Section 10.1 "Goodbye Packets") for
   the old rdata, to cause it to be deleted from peer caches, before
   announcing the new rdata.

[23] In the case of unique records, a host SHOULD omit the "goodbye"
   announcement, since the cache-flush bit on the newly announced records
   will cause old rdata to be flushed from peer caches anyway.

[24] A host may update the contents of any of its records at any time,
   though a host SHOULD NOT update records more frequently than ten times
   per minute.

** s9: conflict resolution [3]

[1] Whenever a Multicast DNS Responder receives any Multicast DNS response
   (solicited or otherwise) containing a conflicting resource record in any
   of the Resource Record Sections, the Multicast DNS Responder MUST
   immediately reset its conflicted unique record to probing state

[2] The protocol used in the Probing phase will determine a winner and a
   loser, and the loser MUST cease using the name, and reconfigure.

[3] It is very important that any host receiving a resource record that
   conflicts with one of its own MUST take action as described above.

** s10: resource record TTL values, cache coherency [14]

[1] As a general rule, the recommended TTL value for Multicast DNS resource
   records with a host name as the resource record's name (e.g.  A, AAAA,
   HINFO, etc.) or a host name contained within the resource record's rdata
   (e.g. SRV, reverse mapping PTR record, etc.) SHOULD be 120 seconds.

[2] In the case where a host knows that certain resource record data is
   about to become invalid (for example when the host is undergoing a clean
   shutdown) the host SHOULD send an unsolicited mDNS response packet,
   giving the same resource record name, rrtype, rrclass and rdata, but an
   RR TTL of zero.

[3] Queriers receiving a Multicast DNS Response with a TTL of zero SHOULD
   NOT immediately delete the record from the cache, but instead record a
   TTL of 1 and then delete the record one second later.

[4] Whenever a host has a resource record with new data, or with what might
   potentially be new data (e.g. after rebooting, waking from sleep,
   connecting to a new network link, changing IP address, etc.), the host
   needs to inform peers of that new data. In cases where the host has not
   been continuously connected and participating on the network link, it
   MUST first Probe to re-verify uniqueness of its unique records

[5] Having completed the Probing step if necessary, the host MUST then send
   a series of unsolicited announcements to update cache entries in its
   neighbor hosts.

[6,7] Any time a host sends a response packet containing some members of a
   unique RRSet, it MUST send the entire RRSet, preferably in a single
   packet, or if the entire RRSet will not fit in a single packet, in a
   quick burst of packets sent as close together as possible. The host MUST
   set the cache-flush bit on all members of the unique RRSet.

[8] The "cache-flush" bit MUST NOT be set in any resource records in a
   response packet sent in legacy unicast responses to UDP ports other than
   5353.

[9] The "cache-flush" bit MUST NOT be set in any resource records in the
   Known-Answer list of any query packet.

[10] The "cache-flush" bit MUST NOT ever be set in any shared resource
   record.

*** cache flush on failure indication

[11] When the cache receives this hint that it should reconfirm some
   record, it MUST issue two or more queries for the resource record in
   question.

[12] If no response is received within ten seconds, then, even though its
   TTL may indicate that it is not yet due to expire, that record SHOULD be
   promptly flushed from the cache.

*** POOF

[13,14] After seeing two or more of these queries, and seeing no multicast
   response containing the expected answer within ten seconds, then even
   though its TTL may indicate that it is not yet due to expire, that
   record SHOULD be flushed from the cache. The host SHOULD NOT perform its
   own queries to re-confirm that the record is truly gone.

** s11: source address check [4]

[1] All Multicast DNS responses (including responses sent via unicast)
   SHOULD be sent with IP TTL set to 255.

[2] A host sending Multicast DNS queries to a link-local destination
   address (including the 224.0.0.251 and FF02::FB link-local multicast
   addresses) MUST only accept responses to that query that originate from
   the local link, and silently discard any other response packets.

[3] Since queriers will ignore responses apparently originating outside the
   local subnet, a Responder SHOULD avoid generating responses that it can
   reasonably predict will be ignored.

[4] If a Responder receives a query addressed to the link-local multicast
   address 224.0.0.251, from a source address not apparently on the same
   subnet as the Responder (or, in the case of IPv6, from a source IPv6
   address for which the Responder does not have any address with the same
   prefix on that interface) then even if the query indicates that a
   unicast response is preferred (see Section 5.4, "Questions Requesting
   Unicast Responses"), the Responder SHOULD elect to respond by multicast
   anyway, since it can reasonably predict that a unicast response with an
   apparently non-local source address will probably be ignored.

** s13: enabling and disabling multicast DNS [2]

[1,2] The option to fail-over to Multicast DNS for names not ending in
   ".local." SHOULD be a user-configured option, and SHOULD be disabled by
   default because of the possible security issues related to unintended
   local resolution of apparently global names.

** s14: considerations for multiple interfaces [2]


[1] A host SHOULD defend its dot-local host name on all active interfaces
   on which it is answering Multicast DNS queries.

[2] Except in the case of proxying and other similar specialized uses,
   addresses in IPv4 or IPv6 address records in Multicast DNS responses
   MUST be valid for use on the interface on which the response is being
   sent.

** s15: Considerations for Multiple Responders on the Same Machine

[1] In most operating systems, incoming *multicast* packets can be
   delivered to *all* open sockets bound to the right port number, provided
   that the clients take the appropriate steps to allow this.  For this
   reason, all Multicast DNS implementations SHOULD use the SO_REUSEPORT
   and/or SO_REUSEADDR options (or equivalent as appropriate for the
   operating system in question) so they will all be able to bind to UDP
   port 5353 and receive incoming multicast packets addressed to that port.
   
** s16: Multicast DNS character set [4]

[1] Multicast DNS is a new protocol and doesn't (yet) have old buggy legacy
   implementations to constrain the design choices. Accordingly, it adopts
   the simple obvious elegant solution: all names in Multicast DNS MUST be
   encoded as precomposed UTF-8 [RFC3629] "Net-Unicode" [RFC5198] text.

[2] Multicast DNS names MUST NOT contain a "Byte Order Mark".

[3] Any occurrence of the Unicode character U+FEFF at the start or anywhere
   else in a Multicast DNS name MUST be interpreted as being an actual
   intended part of the name, representing (just as for any other legal
   unicode value) an actual literal instance of that character (in this
   case a zero-width non-breaking space character).

[4] Multicast DNS implementations MUST NOT use any other encodings apart
   from precomposed UTF-8 (US-ASCII being considered a compatible subset of
   UTF-8).

** s17: Multicast DNS message size [5]

[1] In the case of a single mDNS Resource Record which is too large to fit
   in a single MTU-sized multicast response packet, a Multicast DNS
   Responder SHOULD send the Resource Record alone, in a single IP
   datagram, using multiple IP fragments.

[2] Resource Records this large SHOULD be avoided, except in the very rare
   cases where they really are the appropriate solution to the problem at
   hand.

[3] Implementers should be aware that many simple devices do not
   re-assemble fragmented IP datagrams, so large Resource Records SHOULD
   NOT be used except in specialized cases where the implementer knows that
   all receivers implement reassembly, or where the large Resource Record
   contains optional data which is not essential for correct operation of
   the client.

[4] A Multicast DNS packet larger than the interface MTU, which is sent
   using fragments, MUST NOT contain more than one Resource Record.

[5] Even when fragmentation is used, a Multicast DNS packet, including IP
   and UDP headers, MUST NOT exceed 9000 bytes.

** s18: Multicast DNS Message Format [36]


[1] Multicast DNS implementations SHOULD listen for unsolicited responses
   issued by hosts booting up (or waking up from sleep or otherwise joining
   the network).

[2] Multicast DNS implementations SHOULD examine all received Multicast DNS
   response messages for useful answers, without regard to the contents of
   the ID field or the Question Section.
=> also probes(?)


[3] In multicast query messages, the Query ID SHOULD be set to zero on
   transmission.

[4] In multicast responses, including unsolicited multicast responses, the
   Query ID MUST be set to zero on transmission, and MUST be ignored on
   reception.


[5] In legacy unicast response messages generated specifically in response
   to a particular (unicast or multicast) query, the Query ID MUST match
   the ID from the query message.


[6,7] In query messages the QR bit MUST be zero.  In response messages the
   QR bit MUST be one.


[8] (OPCODE) In both multicast query and multicast response messages, MUST
be zero


[9,10] (AA (Authoritative Answer) Bit) In query messages, the Authoritative
   Answer bit MUST be zero on transmission, and MUST be ignored on
   reception.

[11] In response messages for Multicast Domains, the Authoritative Answer
   bit MUST be set to one (not setting this bit would imply there's some
   other place where "better" information may be found) and MUST be ignored
   on reception.

[12] (TC bit set) A Responder SHOULD record this fact, and wait for those
   additional Known-Answer records, before deciding whether to respond.

[13] In multicast response messages, the TC bit MUST be zero on
   transmission, and MUST be ignored on reception.

[14] In legacy unicast response messages, the TC bit has the same meaning
   as in conventional unicast DNS: it means that the response was too large
   to fit in a single packet, so the Querier SHOULD re-issue its query
   using TCP in order to receive the larger response.

[15,16] (RD (Recursion Desired) Bit) In both multicast query and multicast
   response messages, the Recursion Desired bit SHOULD be zero on
   transmission, and MUST be ignored on reception.

[17,18] (RA (Recursion Available) Bit) In both multicast query and
   multicast response messages, the Recursion Available bit MUST be zero on
   transmission, and MUST be ignored on reception.

[19,20] (Z (Zero) Bit) In both query and response messages, the Zero bit
   MUST be zero on transmission, and MUST be ignored on reception.

[21, 22] (AD (Authentic Data) Bit) In both multicast query and multicast
   response messages the Authentic Data bit [RFC2535] MUST be zero on
   transmission, and MUST be ignored on reception.

[23, 24] (CD (Checking Disabled) Bit) In both multicast query and multicast
   response messages, the Checking Disabled bit [RFC2535] MUST be zero on
   transmission, and MUST be ignored on reception.

[25, 26] (RCODE (Response Code)) In both multicast query and multicast
   response messages, the Response Code MUST be zero on
   transmission. Multicast DNS messages received with non-zero Response
   Codes MUST be silently ignored.

[27] When generating Multicast DNS packets, implementations SHOULD use name
   compression wherever possible to compress the names of resource records,
   by replacing some or all of the resource record name with a compact
   two-byte reference to an appearance of that data somewhere earlier in
   the packet [RFC1035].

[28]   This applies not only to Multicast DNS Responses, but also to
   Queries. When a Query contains more than one question, successive
   questions in the same message often contain similar names, and
   consequently name compression SHOULD be used, to save bytes. 

[29] In addition, Queries may also contain Known Answers in the Answer
   Section, or probe tie-breaking data in the Authority Section, and these
   names SHOULD similarly be compressed for network efficiency.

[30] In addition to compressing the *names* of resource records, names that
   appear within the *rdata* of the following rrtypes SHOULD also be
   compressed in all Multicast DNS packets: NS, CNAME, PTR, DNAME, SOA, MX,
   AFSDB, RT, KX, RP, PX, SRV, NSEC

[31] Until future IETF Standards Action specifying that names in the rdata
   of other types should be compressed, names that appear within the rdata
   of any type not listed above MUST NOT be compressed.

[32]   Implementations receiving Multicast DNS packets MUST correctly decode
   compressed names appearing in the Question Section, and compressed
   names of resource records appearing in other sections.

[33]   In addition, implementations MUST correctly decode compressed names
   appearing within the *rdata* of the rrtypes listed above. 

[34] Where possible, implementations SHOULD also correctly decode
   compressed names appearing within the *rdata* of other rrtypes known to
   the implementers at the time of implementation, because such forward-
   thinking planning helps facilitate the deployment of future
   implementations that may have reason to compress those rrtypes.

[35] Since all Multicast DNS implementations were created after 1996, all
   Multicast DNS implementations are REQUIRED to decode compressed SRV
   records correctly.

[36] In legacy unicast responses generated to answer legacy queries, name
   compression MUST NOT be performed on SRV records.


