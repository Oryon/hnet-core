%start Client::Init
%class SKV

%map Client
%%

// State Transition End State Action(s)
Init 
Entry { init_client(); }
{
  Initialized Connecting { }
}

Default
{
  HaveUpdate(k: Key, v:Value) nil { store_local_update(k, v); }
  AddListener(k: String, cb: Callback) nil { add_listener(k, cb); }
  RemoveListener(l: Listener) nil { delete_listener(l); }
}

Connecting 
Entry { connect(); }
Exit { clear_ev(); }
{
  Connected WaitVersion {}
  ConnectFailed [ ctxt:is_long_lived() ] Server::Init {}
  ConnectFailed Terminal::ClientFailConnect {  }
}

WaitUpdates
Entry  { send_local_updates(); send_listeners(); }
Exit { clear_jsoncodec(); }
{
  HaveUpdate(k: Key, v:Value) nil { send_update(k, v); }
  AddListener(k: String, cb:Callback) nil { l = add_listener(k, cb); send_add_listener(l); }
  RemoveListener(l: Listener) nil { send_remove_listener(l); delete_listener(l); }
  ConnectionClosed Connecting { }
}

WaitVersion
Entry  { wrap_socket_jsoncodec(); }
Exit { }
{
  ReceiveVersion(v: Value) [ctxt:protocol_is_current_version(v)] WaitUpdates {}
  ReceiveVersion(v: Value) Terminal::ClientFailConnect {}
  ConnectionClosed Connecting { clear_jsoncodec(); }
// receiving of updates handled here; however, it doesn't affect system state machine
// ReceiveUpdate nil { received_update(); }
}

%%

%map Server
%%

Default
{
  HaveUpdate(k: Key, v:Value) nil { store_local_update(k, v); }
  AddListener(k: String, cb: Callback) nil { add_listener(k, cb); }
  RemoveListener(l: Listener) nil { delete_listener(l); }
}

Init 
Entry { init_server(); }
{
  Initialized Binding {}
}

Binding 
Entry { bind(); }
{
  Bound WaitConnections { }
  BindFailed InitWaitTimeout { }  
}

InitWaitTimeout 
Entry { increase_retry_timer(); start_retry_timer(); }
{
  Timeout Client::Connecting { }
}

WaitConnections 
Entry { }
{
// new connection loop here - no affect on the state machine though
}
%%

%map Terminal
%%

ClientFailConnect
Entry { fail("unable to connect to SKV"); }
{
}

%%
