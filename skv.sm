%start SKV::Init
%class SKV

%map SKV
%%

// State Transition End State Action(s)
Init 
Entry { init(); }
{
  Initialized Connecting { }
}

Default
{
  HaveUpdate(k: Key, v:Value) nil { store_local_update(k, v); }
  AddListener(k: String, cb: Callback) nil { add_listener(k, cb); }
  RemoveListener(l: Listener) nil { delete_listener(l); }
}

Connecting 
Entry { connect(); }
{
  Connected WaitUpdates {}
  ConnectFailed [ ctxt.is_long_lived() ] Master::Init {}
  ConnectFailed nil { fail("Unable to connect"); }
}

WaitUpdates
Entry  { send_local_updates(); send_listeners(); }
{
  HaveUpdate(k: Key, v:Value) nil { send_update(k, v); }
  AddListener(k: String, cb:Callback) nil { l = add_listener(k, cb); send_add_listener(l); }
  RemoveListener(l: Listener) nil { send_remove_listener(l); delete_listener(l); }
// receiving of updates handled here; however, it doesn't affect system state machine
// ReceiveUpdate nil { received_update(); }
}

//Die 
//Entry { fail(); }
//{
//}

%%

%map Master
%%

Init 
Entry { init_master(); }
{
  Initialized WaitConnections { }
  ListenFailed InitWaitTimeout { }  
}

InitWaitTimeout 
Entry { increase_retry_timer(); start_retry_timer(); }
{
  Timeout SKV::Connecting { }
}

WaitConnections 
Entry { start_wait_connections(); }
{
// new connection loop here - no affect on the state machine though
}
%%

