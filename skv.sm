%start Client::Init
%class SKV

%map Client
%%

// State Transition End State Action(s)
Init 
Entry { init_client(); }
{
  Initialized Connecting { }
}

Default
{
  HaveUpdate(k: Key, v:Value) nil { store_local_update(k, v); }
  AddListener(k: String, cb: Callback) nil { add_listener(k, cb); }
  RemoveListener(l: Listener) nil { delete_listener(l); }
}

Connecting 
Entry { connect(); }
Exit { clear_ev(); }
{
  Connected WaitUpdates {}
  ConnectFailed [ ctxt:is_long_lived() ] Server::Init {}
  ConnectFailed Terminal::ClientFailConnect {  }
}

WaitUpdates
Entry  { send_local_updates(); send_listeners(); }
{
  HaveUpdate(k: Key, v:Value) nil { send_update(k, v); }
  AddListener(k: String, cb:Callback) nil { l = add_listener(k, cb); send_add_listener(l); }
  RemoveListener(l: Listener) nil { send_remove_listener(l); delete_listener(l); }
  ConnectionClosed Connecting { remove_closed(); }
// receiving of updates handled here; however, it doesn't affect system state machine
// ReceiveUpdate nil { received_update(); }
}

%%

%map Server
%%

Init 
Entry { init_server(); }
{
  Initialized Binding {}
}

Binding 
Entry { bind(); }
{
  Bound WaitConnections { }
  BindFailed InitWaitTimeout { }  
}

InitWaitTimeout 
Entry { increase_retry_timer(); start_retry_timer(); }
{
  Timeout Client::Connecting { }
}

WaitConnections 
Entry { start_wait_connections(); }
{
// new connection loop here - no affect on the state machine though
}
%%

%map Terminal
%%

ClientFailConnect
Entry { fail("unable to connect to SKV"); }
{
}

%%
