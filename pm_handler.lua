#!/usr/bin/env lua
-- -*-lua-*-
--
-- $Id: pm_handler.lua $
--
-- Author: Markus Stenberg <markus stenberg@iki.fi>
--
-- Copyright (c) 2012 cisco Systems, Inc.
--
-- Created:       Wed Nov  7 19:33:20 2012 mstenber
-- Last modified: Mon Oct  7 16:55:44 2013 mstenber
-- Edit time:     35 min
--

-- single pm handler prototype

require 'mst'
require 'mst_eventful'

local _eventful = mst_eventful.eventful

module(..., package.seeall)

pm_handler = _eventful:new_subclass{class='pm_handler', 
                                    mandatory={'_pm'},
                                    events={'changed'}}

function pm_handler:repr_data()
   return '?'
end

function pm_handler:init()
   _eventful.init(self)
   self.file_contents = {}
   self.shell = self._pm.shell
end

function pm_handler:queue()
   local old = self.queued
   self.queued = true
   return not old
end

function pm_handler:ready()
   return true
end

function pm_handler:maybe_tick()
   if not self.tick
   then
      return
   end
   if not self:ready()
   then
      return
   end
   return self:tick()
end

function pm_handler:maybe_run()
   if not self.queued
   then
      --self:d(' not queued')
      return
   end

   -- if not ready, not going to do a thing
   self:d('maybe_run')

   if not self:ready()
   then
      self:d(' not ready')
      return
   end
   self.queued = nil
   local v = self:run()
   if v and v > 0
   then
      self:changed()
   end
end

function pm_handler:run()
   -- REALLY implemented by the children
end

function pm_handler:time()
   return self._pm:time()
end

function pm_handler:write_to_file(fpath, t0, comment_prefix)
   local t = mst.array:new()
   local s0 = table.concat(t0, '\n')
   if comment_prefix
   then
      t:insert(comment_prefix)
      t:insert(comment_prefix .. fpath)
      t:insert(comment_prefix .. 
               'automatically generated by ' .. self.class .. 
               ' on ' .. os.date())
      t:insert(comment_prefix)
   end
   t:insert(s0)
   t:insert('')
   local s = t:join('\n')
   if self.file_contents[fpath] == s0
   then
      return
   end
   self.file_contents[fpath] = s0

   local f, err = io.open(fpath, 'w')
   self:a(f, 'unable to open for writing', fpath, err)
   f:write(s)
   -- close the file
   io.close(f)
   return true
end

-- openwrt-specific utilities (used only in pm_netifd_*)

function pm_handler:get_uci_cursor()
   require 'uci'
   return uci.cursor()
end

function pm_handler:get_uci_cursor()
   require 'uci'
   return uci.cursor()
end

function pm_handler:get_ubus_connection()
   require 'ubus'
   return ubus.connect()
end

pm_handler_with_pa = pm_handler:new_subclass{class='pm_handler_with_pa'}

function pm_handler_with_pa:init()
   -- parent init first
   pm_handler.init(self)

   -- then connect to relevant change notifications we're interested about
   self:connect_method(self._pm.usp_changed, self.usp_changed)
   self:connect_method(self._pm.lap_changed, self.lap_changed)
   self:connect_method(self._pm.skv_changed, self.skv_changed)
end

function pm_handler_with_pa:get_if_table()
   if not self.if_table
   then
      -- shared datastructures
      self.if_table = linux_if.if_table:new{shell=self.shell} 
   end
   return self.if_table
end


function pm_handler_with_pa:usp_changed(usp)
   self.usp = usp
   self:queue()
end

function pm_handler_with_pa:lap_changed(lap)
   self.lap = lap
   self:queue()
end

function pm_handler_with_pa:skv_changed(k, v)
   -- nop
end

function pm_handler_with_pa:ready()
   if not self.usp
   then
      self:d('no usp, not ready')
      return
   end
   if not self.lap
   then
      self:d('no lap, not ready')
      return
   end
   return true
end

pm_handler_with_pa_dns = pm_handler_with_pa:new_subclass{class='pm_handler_with_pa_dns'}

function pm_handler_with_pa_dns:skv_changed(k, v)
   if k == elsa_pa.OSPF_IPV4_DNS_KEY
   then
      self.ospf_v4_dns = v or {}
   elseif k == elsa_pa.OSPF_IPV4_DNS_SEARCH_KEY
   then
      self.ospf_v4_dns_search = v or {}
   elseif k == elsa_pa.OSPF_DNS_KEY
   then
      self.ospf_dns = v or {}
   elseif k == elsa_pa.OSPF_DNS_SEARCH_KEY
   then
      self.ospf_dns_search = v or {}
   elseif k == elsa_pa.HP_SEARCH_LIST_KEY
   then
      self.hp_search = v or {}
   else
      return
   end
   self:queue()
end

