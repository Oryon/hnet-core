diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e511a9d
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,32 @@
+# manually created .gitignore file for the BIRD Internet Routing Daemon #
+
+# Custom #
+##########
+
+# ignore executables created by make
+/bird
+/birdc
+
+# ignore ./configure
+/configure
+
+# ignore files create by ./configure
+/Makefile
+/config.log
+/config.status
+/obj
+
+# ignore files created by autoconf, except configure
+/autom4te.cache
+
+# editor files
+*~
+.#*
+#*#
+
+# cscope 
+cscope.files
+cscope.out
+
+# test stuff
+proto/ospf/test/t-elsa
diff --git a/Doc b/Doc
deleted file mode 100644
index f5f1508..0000000
--- a/Doc
+++ /dev/null
@@ -1,7 +0,0 @@
-C doc
-C nest
-C conf
-C filter
-C proto
-C sysdep
-C lib
diff --git a/README.elsa.md b/README.elsa.md
new file mode 100644
index 0000000..ff042c3
--- /dev/null
+++ b/README.elsa.md
@@ -0,0 +1,64 @@
+API
+===
+
+OSPF=>X
+-------
+
+- init
+ elsa = elsa_create(client)
+
+- LSA change notification (received from outside / generated internally)
+ elsa_notify_changed_lsa(lsa)
+ elsa_notify_deleting_lsa(lsa)
+ elsa_notify_duplicate_lsa(lsa)
+
+- dispatch (to provide access to event loop)
+ elsa_dispatch()
+
+- destroy
+ elsa_destroy(elsa)
+
+
+X=>OSPF
+-------
+
+- get router ID
+ rid = elsai_get_rid(client)
+
+- router ID should be changed
+ elsai_change_rid(client)
+
+- get LSAs (of type X (and rid R))
+ lsa = elsai_get_lsa_by_type(client, type)
+ lsa = elsai_get_lsa_by_type_next(client, lsa)
+
+ lsa = elsai_get_lsa_by_type_rid(client, type, rid)
+ lsa = elsai_get_lsa_by_type_rid_next(client, lsa)
+
+Look at what the structures look like under Quagga + BIRD
+---------------------------------------------------------
+
+### Quagga
+
+- lsdb, lsa structures
+    - lsdb some sort of hackish tree of lsa's
+    - lsa itself identified by
+      uint16 type, uint32 id+adv_router (areas=?)
+
+- store+originate (link LSA, random example)
+  ospf6_link_lsa_originate called from soft-thread
+  .. malloc new LSA structure
+  .. eventually call ospf6_lsa_originate 
+  [ needs: lsa struct with header + body ]
+
+### BIRD
+
+- lsdb: 
+- ospf_hash_find_header
+    - ospf_hash_find (domain [== area], lsa [== Quagga id, link state id in
+      RFC], rtr, type [== lsa type / Quagga type])
+
+ [ needs: lsa struct (can be temporary), body (should be allocated
+ appropriately ) ]
+
+- store+originate: .. eventually lsa_install_new => WIY
diff --git a/bird6.conf.elsa b/bird6.conf.elsa
new file mode 100644
index 0000000..7f51c98
--- /dev/null
+++ b/bird6.conf.elsa
@@ -0,0 +1,43 @@
+#log syslog { debug, trace, info, remote, warning, error, auth, fatal, bug };
+log stderr all;
+log "/tmp/bird6.log" all;
+
+router id random; # can be overridden by specific protocols
+router id remember "/tmp/router_id";
+
+debug protocols {states, routes, filters, interfaces, events, packets};
+
+protocol kernel {
+	persist;		# Don't remove routes on bird shutdown
+	scan time 20;		# Scan kernel routing table every 20 seconds
+	export all;		# Default is export none
+}
+
+protocol device {
+	scan time 10;		# Scan interfaces every 10 seconds
+}
+
+protocol static {
+}
+
+protocol ospf MyOSPF {
+	prefix assignment yes;
+	duplicate rid detection yes { };
+	usableprefix {
+		fda9:b0b:ca7::/48;
+		fda9:dead:beef::/63;
+		fda9:1010:1010::/64;
+	};
+	area 0.0.0.0 {
+		stub no;
+		interface "*" {
+			hello 10;
+			retransmit 6;
+			cost 10;
+			transmit delay 5;
+			dead count 4;
+			type broadcast;
+			wait 15;
+		};
+	};
+}
diff --git a/conf/conf.c b/conf/conf.c
index 9375861..7679b5e 100644
--- a/conf/conf.c
+++ b/conf/conf.c
@@ -118,8 +118,8 @@ config_parse(struct config *c)
   if (EMPTY_LIST(c->protos))
     cf_error("No protocol is specified in the config file");
 #ifdef IPV6
-  if (!c->router_id)
-    cf_error("Router ID must be configured manually on IPv6 routers");
+  if (!c->router_id && !c->rid_is_random)
+    cf_error("Router ID must be configured on IPv6 routers");
 #endif
   return 1;
 }
@@ -176,9 +176,44 @@ config_del_obstacle(struct config *c)
     }
 }
 
+static void
+global_set_rid(struct config *new, struct config *old)
+{
+  /* random router ID generation happens if:
+     - we are configured to generate a random RID
+     AND
+     - there is no value stored in memory or we are set to not look at memory
+     AND
+     - this is a first time configuration or old config wasn't random */
+  if(new->rid_is_random && (!old || !old->router_id || !old->rid_is_random))
+  {
+    u32 rid;
+    if(new->rid_filename && (rid = read_rid(new->rid_filename)))
+    {
+      log(L_INFO "Read router id %R from file.", rid);
+      new->router_id = rid;
+    }
+    else
+    {
+      do {
+        new->router_id = random_u32();
+      } while (new->router_id == 0);
+      log(L_INFO "Randomly generated router id %R.", new->router_id);
+    }
+  }
+
+  if (!new->router_id)
+    new->router_id = old->router_id;
+
+  if(new->rid_filename)
+    write_rid(new->rid_filename, new->router_id);
+}
+
 static int
 global_commit(struct config *new, struct config *old)
 {
+  global_set_rid(new, old);
+
   if (!old)
     return 0;
 
@@ -187,8 +222,6 @@ global_commit(struct config *new, struct config *old)
       (old->listen_bgp_flags != new->listen_bgp_flags))
     log(L_WARN "Reconfiguration of BGP listening socket not implemented, please restart BIRD.");
 
-  if (!new->router_id)
-    new->router_id = old->router_id;
   if (new->router_id != old->router_id)
     return 1;
   return 0;
diff --git a/conf/conf.h b/conf/conf.h
index c76832b..b6ee00c 100644
--- a/conf/conf.h
+++ b/conf/conf.h
@@ -28,6 +28,8 @@ struct config {
   struct rtable_config *master_rtc;	/* Configuration of master routing table */
 
   u32 router_id;			/* Our Router ID */
+  byte rid_is_random;                   /* Whether or not RID was generated by a PRNG */
+  char *rid_filename;                   /* File to store random RID in (NULL = no storage) */
   ip_addr listen_bgp_addr;		/* Listening BGP socket should use this address */
   unsigned listen_bgp_port;		/* Listening BGP socket should use this port (0 is default) */
   u32 listen_bgp_flags;			/* Listening BGP socket should use these flags */
diff --git a/configure.in b/configure.in
index 54993df..63b5440 100644
--- a/configure.in
+++ b/configure.in
@@ -20,6 +20,22 @@ AC_ARG_VAR([FLEX], [location of the Flex program])
 AC_ARG_VAR([BISON], [location of the Bison program])
 AC_ARG_VAR([M4], [location of the M4 program])
 
+m4_include([tools/lua.m4])
+
+elsa_sources=""
+AX_LUA_HEADERS
+AX_LUA_LIBS
+if test -n "$LUA_LIB" ; then
+   if test "$cross_compiling" = "no" ; then
+      AX_LUA_LIB_VERSION()
+   fi
+   elsa_sources="elsa.c elsa_platform.c elsa_wrap.c"
+   AC_DEFINE(ELSA_ENABLED)
+fi
+AC_SUBST(elsa_sources)
+
+CFLAGS="$CFLAGS $LUA_INCLUDE"
+CPPFLAGS="$CPPFLAGS $LUA_INCLUDE"
 
 if test "$srcdir" = . ; then
 	# Building in current directory => create obj directory holding all objects
@@ -74,6 +90,8 @@ AC_SUBST(CONFIG_FILE)
 AC_SUBST(CONTROL_SOCKET)
 
 AC_SEARCH_LIBS(clock_gettime,[c rt posix4])
+LIBS="$LIBS $LUA_LIB"
+AC_SUBST(LIBS)
 
 AC_CANONICAL_HOST
 
diff --git a/elsa.lua b/elsa.lua
new file mode 100644
index 0000000..da2d1d2
--- /dev/null
+++ b/elsa.lua
@@ -0,0 +1,337 @@
+#!/usr/bin/env lua
+-- -*-lua-*-
+--
+-- $Id: elsa.lua $
+--
+-- Author: Markus Stenberg <fingon@iki.fi>
+--
+-- Copyright (c) 2012 cisco Systems, Inc.
+--
+-- Created:       Wed Sep 26 23:01:06 2012 mstenber
+-- Last modified: Wed Oct 24 13:20:46 2012 mstenber
+-- Edit time:     139 min
+--
+
+require 'mst'
+require 'ssloop'
+require 'skv'
+require 'elsa_pa'
+require 'linux_if'
+
+elsaw = mst.create_class{class='elsaw', mandatory={'c'}}
+
+function elsaw:init()
+   -- something we need to do here?
+   self.last = ''
+   self.sn = 0
+
+   -- calculate the hardware fingerprint
+   local if_table = linux_if.if_table:new{shell=mst.execute_to_string}
+   local m = if_table:read_ip_ipv6()
+   local t = mst.array:new()
+   
+   for ifname, ifo in pairs(m)
+   do
+      local hwa = ifo:get_hwaddr()
+      if hwa
+      then
+         t:insert(hwa)
+      end
+   end
+
+   -- must have at least one hw address
+   mst.a(#t > 0)
+   
+   -- in-place sort 
+   t:sort()
+   self.hwf = t:join(' ')
+
+   mst.d('got hwf', self.hwf)
+
+end
+
+function elsaw:iterate_lsa(f, criteria)
+   mst.a(criteria, 'criteria mandatory')
+   mst.a(criteria.type, 'criteria.type mandatory')
+   for lsa in elsai_lsas_by_type(self.c, criteria.type)
+   do
+      f(lsa)
+   end
+end
+
+local _eif_cache
+
+function elsaw:iterate_if(rid, f)
+   for i in elsai_interfaces(self.c)
+   do
+      f(i)
+   end
+end
+
+function elsaw:iterate_ifo_neigh(rid, ifo, f)
+   local i = _eif_cache[ifo.index]
+   mst.a(i, 'unable to find interface', ifo)
+   local n = elsac.elsai_if_get_neigh(self.c, i)
+   while n
+   do
+      local iid = elsac.elsai_neigh_get_iid(self.c, n)
+      local rid = elsac.elsai_neigh_get_rid(self.c, n)
+      f{iid=iid, rid=rid}
+      n = elsac.elsai_neigh_get_next(self.c, n)
+   end
+end
+
+function elsaw:originate_lsa(d)
+   self:a(d.type == elsa_pa.AC_TYPE, 'support for other types missing')
+   if self.last == d.body
+   then
+      mst.d('skipped duplicate LSA')
+      return
+   end
+   self.last = d.body
+   self.sn = self.sn + 1
+   elsac.elsai_lsa_originate(self.c, d.type, 0, self.sn, self.last)
+end
+
+should_change_rid = false
+
+function elsaw:change_rid()
+   mst.d('should change rid')
+   should_change_rid = true
+end
+
+function elsaw:get_hwf()
+   return self.hwf
+end
+
+function elsaw:route_to_rid(rid)
+   local nh, ifname = elsac.elsai_route_to_rid(self.c, rid)
+   local r = {nh=nh, ifname=ifname}
+   return r
+end
+
+-- iterate through the interfaces provided by the low-level elsai interface,
+-- wrapping them in tables as we go, and leeching off all
+function elsai_interfaces_iterator(c, k)
+   local i
+   if not k
+   then
+      i = elsac.elsai_if_get(c)
+   else
+      i = elsac.elsai_if_get_next(c, getmetatable(k).i)
+   end
+   if not i
+   then
+      return
+   end
+   local t = {}
+   setmetatable(t, {i=i})
+   t.name = elsac.elsai_if_get_name(c, i)
+   t.index = elsac.elsai_if_get_index(c, i)
+   t.priority = elsac.elsai_if_get_priority(c, i)
+   _eif_cache[t.index] = i
+   --mst.d(i, mst.repr(t))
+   return t
+end
+
+function elsai_interfaces(c)
+   -- clear the cache every time iteration starts 
+   _eif_cache = {}
+   return elsai_interfaces_iterator, c, nil
+end
+
+function wrap_lsa(l)
+   local t = {}
+   setmetatable(t, {l=l})
+   t.type = elsac.elsai_lsa_get_type(l)
+   t.rid = elsac.elsai_lsa_get_rid(l)
+   t.lsid = elsac.elsai_lsa_get_lsid(l)
+   t.body = elsac.elsai_lsa_get_body(l)
+   return t
+end
+
+-- similar iterator for lsas by type
+function elsai_lsas_by_type_iterator(state, k)
+   local c, type = unpack(state)
+   local l
+   if not k
+   then
+      l = elsac.elsai_get_lsa_by_type(c, type)
+   else
+      l = elsac.elsai_get_lsa_by_type_next(c, getmetatable(k).l)
+   end
+   if not l
+   then
+      return
+   end
+   local t = wrap_lsa(l)
+   assert(t.type == type, "invalid type for lsa")
+   return t
+end
+
+function elsai_lsas_by_type(c, type)
+   return elsai_lsas_by_type_iterator, {c, type}, nil
+end
+
+-- convenience methods to get array / table of interfaces
+
+function elsai_lsa_array_by_type(c, type)
+   local t = {}
+   for l in elsai_lsas_by_type(c, type)
+   do
+      table.insert(t, l)
+   end
+   return t
+end
+
+function elsai_interface_table(c)
+   local t = {}
+   for i in elsai_interfaces(c)
+   do
+      t[i.name] = i
+   end
+   return t
+end
+
+function _debug_state()
+   local e = elsac.elsa_active_get()
+   print('got active', e)
+
+   local c = e.client
+   print('got client', c)
+
+   local it = elsai_interface_table(c)
+   print('got interfaces', mst.repr(it))
+
+   local l = elsai_lsa_array_by_type(c, elsac.LSA_T_LINK)
+   print('got link array', mst.repr(l))
+   
+   local rid = elsac.elsai_get_rid(c)
+   print('router rid', string.format('%x', rid))
+end
+
+local _elsa_pa = false
+
+function get_elsa_pa()
+   local e = elsac.elsa_active_get()
+   mst.d('got active', e)
+   
+   local c = e.client
+   mst.d('got client', c)
+   
+   local rid = elsac.elsai_get_rid(c)
+   mst.d('router rid', string.format('%x', rid))
+
+   if not _elsa_pa
+   then
+      local ew = elsaw:new{c=c}
+      local skv = skv.skv:new{long_lived=true}
+      _elsa_pa = elsa_pa.elsa_pa:new{elsa=ew, skv=skv, rid=rid}
+   else
+      _elsa_pa.c = c
+      _elsa_pa.rid = rid
+   end
+   return _elsa_pa
+end
+
+function elsa_dispatch()
+   mst.d_xpcall(function ()
+                   -- run the event loop also once, in non-blocking
+                   -- mode (this isn't really pretty, but oh well) not
+                   -- like the local state communication was really
+                   -- that critical
+                   ssloop.loop():poll(0)
+
+                   local epa = get_elsa_pa()
+
+                   -- first off, take care of the rid change
+                   -- outright if it seems necessary
+                   if should_change_rid
+                   then
+                      mst.d('changing rid')
+                      elsac.elsai_change_rid(epa.c)
+                      should_change_rid = false
+                      return
+                   end
+                   
+                   -- XXX - should we check if we need to run the PA
+                   -- alg?  If so, we should consult both SKV state,
+                   -- and LSA state
+                   epa:run()
+                end)
+end
+
+function elsa_notify_duplicate_lsa()
+   mst.d_xpcall(function ()
+                   local epa = get_elsa_pa()
+                   local lsa = wrap_lsa(elsac.elsa_active_lsa_get())
+
+                   -- other LSAs we can't do anything about anyway
+                   if lsa.type ~= elsa_pa.AC_TYPE
+                   then
+                      return
+                   end
+                   epa:check_conflict(lsa)
+                end)
+end
+
+function elsa_notify_changed_lsa()
+   mst.d_xpcall(function ()
+                   local epa = get_elsa_pa()
+                   local lsa = wrap_lsa(elsac.elsa_active_lsa_get())
+
+                   -- other LSAs we can't do anything about anyway
+                   if lsa.type ~= elsa_pa.AC_TYPE
+                   then
+                      return
+                   end
+
+                   mst.d('changed AC - XXX')
+                end)
+
+end
+
+function elsa_notify_deleting_lsa()
+   mst.d_xpcall(function ()
+                   local epa = get_elsa_pa()
+                   local lsa = wrap_lsa(elsac.elsa_active_lsa_get())
+
+                   mst.d('entered elsa_notify_deleting_lsa')
+
+                   -- other LSAs we can't do anything about anyway
+                   if lsa.type ~= elsa_pa.AC_TYPE
+                   then
+                      return
+                   end
+
+                   mst.d('deleting AC - XXX')
+                end)
+
+end
+
+-- capture the io.stdout/stderr
+function create_log_wrapper(prefix)
+   return function (s)
+      elsac.elsa_log_string(string.format("%s %s", prefix, s))
+      for i, v in ipairs(mst.string_split(s, "\n"))
+      do
+         local sl = mst.string_strip(v)
+         if #sl
+         then
+            elsac.elsa_log_string(string.format("[lua] %s", v))
+         end
+      end
+   end
+end
+
+io.stdout = {write = create_log_wrapper("[lua-o]")}
+io.stderr = {write = create_log_wrapper("[lua-e]")}
+
+-- override the print stmt
+function print(...)
+   local l = mst.array_map({...}, tostring)
+   elsac.elsa_log_string(string.format('[lua] %s', table.concat(l, "\t")))
+end
+
+print('hello from LUA', 2)
+elsac.elsa_log_string('hello from LUA 2')
diff --git a/lib/birdlib.h b/lib/birdlib.h
index 479f3d5..9bdbeda 100644
--- a/lib/birdlib.h
+++ b/lib/birdlib.h
@@ -81,6 +81,10 @@ void debug(char *msg, ...);		/* Printf to debug output */
 #define ASSERT(x) do { } while(0)
 #endif
 
+/* Writing to RID file */
+void write_rid(const char *filename, u32 rid);
+u32 read_rid(const char *filename);
+
 /* Pseudorandom numbers */
 
 u32 random_u32(void);
diff --git a/nest/cmds.c b/nest/cmds.c
index 2a80393..180016c 100644
--- a/nest/cmds.c
+++ b/nest/cmds.c
@@ -22,6 +22,8 @@ cmd_show_status(void)
   cli_msg(-1000, "BIRD " BIRD_VERSION);
   tm_format_datetime(tim, &config->tf_base, now);
   cli_msg(-1011, "Router ID is %R", config->router_id);
+  if(config->rid_is_random)
+    cli_msg(-1011, "Router ID was randomly generated");
   cli_msg(-1011, "Current server time is %s", tim);
   tm_format_datetime(tim, &config->tf_base, boot_time);
   cli_msg(-1011, "Last reboot on %s", tim);
diff --git a/nest/config.Y b/nest/config.Y
index a75dd0c..6f24197 100644
--- a/nest/config.Y
+++ b/nest/config.Y
@@ -49,6 +49,7 @@ CF_KEYWORDS(PASSWORD, FROM, PASSIVE, TO, ID, EVENTS, PACKETS, PROTOCOLS, INTERFA
 CF_KEYWORDS(PRIMARY, STATS, COUNT, FOR, COMMANDS, PREEXPORT, GENERATE, ROA, MAX, FLUSH)
 CF_KEYWORDS(LISTEN, BGP, V6ONLY, DUAL, ADDRESS, PORT, PASSWORDS, DESCRIPTION, SORTED)
 CF_KEYWORDS(RELOAD, IN, OUT, MRTDUMP, MESSAGES, RESTRICT, MEMORY, IGP_METRIC)
+CF_KEYWORDS(RANDOM)
 
 CF_ENUM(T_ENUM_RTS, RTS_, DUMMY, STATIC, INHERIT, DEVICE, STATIC_DEVICE, REDIRECT,
 	RIP, OSPF, OSPF_IA, OSPF_EXT1, OSPF_EXT2, BGP, PIPE)
@@ -75,8 +76,14 @@ CF_GRAMMAR
 
 CF_ADDTO(conf, rtrid)
 
-rtrid: ROUTER ID idval ';' {
-   new_config->router_id = $3;
+rtrid:
+   ROUTER ID idval ';' {
+     new_config->router_id = $3;
+     new_config->rid_is_random = 0;
+   }
+ | ROUTER ID RANDOM ';' {
+     new_config->router_id = 0;
+     new_config->rid_is_random = 1;
    }
  ;
 
@@ -188,7 +195,8 @@ proto_item:
  | IMPORT LIMIT limit_spec { this_proto->in_limit = $3; }
  | EXPORT LIMIT limit_spec { this_proto->out_limit = $3; }
  | TABLE rtable { this_proto->table = $2; }
- | ROUTER ID idval { this_proto->router_id = $3; }
+ | ROUTER ID idval { this_proto->router_id = $3; this_proto->rid_is_random = 0; }
+ | ROUTER ID RANDOM { this_proto->router_id = 0; this_proto->rid_is_random = 1; }
  | DESCRIPTION TEXT { this_proto->dsc = $2; }
  ;
 
diff --git a/nest/proto.c b/nest/proto.c
index 53d3f1a..4aa8f7d 100644
--- a/nest/proto.c
+++ b/nest/proto.c
@@ -372,9 +372,47 @@ proto_init(struct proto_config *c)
 
 int proto_reconfig_type;  /* Hack to propagate type info to pipe reconfigure hook */
 
+/** proto_set_rid - update router_id and rid_is_random fields of a proto_config
+ * @oc: old configuration
+ * @nc: new configuration to be updated
+ *
+ * Compares @oc, @nc and @nc->global router_id and rid_is_random fields and updates
+ * the fields of @nc.
+ * @nc->global fields are used only if @nc fields are not set (both 0).
+ * If configuration is the same as @oc, keep old RID values.
+ */
+static void
+proto_set_rid(struct proto_config *oc, struct proto_config *nc)
+{
+  if(nc->router_id) {
+    log(L_INFO "Proto using router_id %R.", nc->router_id);
+    return;
+  }
+
+  if(nc->rid_is_random)
+  {
+    if(oc && oc->rid_is_random && oc->router_id)
+    {
+      nc->router_id = oc->router_id;
+      log(L_INFO "Proto re-using old router_id %R.", nc->router_id);
+      return;
+    }
+    do {
+        nc->router_id = random_u32();
+      } while (nc->router_id == 0);
+    log(L_INFO "Proto generated router_id %R.", nc->router_id);
+    return;
+  }
+
+  nc->router_id = nc->global->router_id;
+  nc->rid_is_random = nc->global->rid_is_random;
+  log(L_INFO "Proto inherited global router_id %R.", nc->router_id);
+}
+
 static int
 proto_reconfigure(struct proto *p, struct proto_config *oc, struct proto_config *nc, int type)
 {
+
   /* If the protocol is DOWN, we just restart it */
   if (p->proto_state == PS_DOWN)
     return 0;
@@ -383,7 +421,8 @@ proto_reconfigure(struct proto *p, struct proto_config *oc, struct proto_config
   if ((nc->protocol != oc->protocol) ||
       (nc->disabled != p->disabled) ||
       (nc->table->table != oc->table->table) ||
-      (proto_get_router_id(nc) != proto_get_router_id(oc)))
+      (proto_get_router_id(nc) != proto_get_router_id(oc)) ||
+       proto_get_rid_is_random(nc) != proto_get_rid_is_random(nc))
     return 0;
 
 
@@ -500,6 +539,9 @@ protos_commit(struct config *new, struct config *old, int force_reconfig, int ty
 	      nc = sym->def;
 	      nc->proto = p;
 
+              /* Set oc-dependent configuration information in nc */
+              proto_set_rid(oc, nc);
+
 	      /* We will try to reconfigure protocol p */
 	      if (! force_reconfig && proto_reconfigure(p, oc, nc, type))
 		continue;
@@ -538,6 +580,7 @@ protos_commit(struct config *new, struct config *old, int force_reconfig, int ty
       {
 	if (old_config)		/* Not a first-time configuration */
 	  log(L_INFO "Adding protocol %s", nc->name);
+        proto_set_rid(NULL, nc);
 	proto_init(nc);
       }
   DBG("\tdone\n");
@@ -1163,6 +1206,8 @@ proto_cmd_show(struct proto *p, unsigned int verbose, int cnt)
 	cli_msg(-1006, "  Description:    %s", p->cf->dsc);
       if (p->cf->router_id)
 	cli_msg(-1006, "  Router ID:      %R", p->cf->router_id);
+      if(p->cf->rid_is_random)
+        cli_msg(-1006, "  Router ID was randomly generated");
 
       if (p->proto->show_proto_info)
 	p->proto->show_proto_info(p);
diff --git a/nest/protocol.h b/nest/protocol.h
index 11fcb16..9d58530 100644
--- a/nest/protocol.h
+++ b/nest/protocol.h
@@ -92,6 +92,8 @@ struct proto_config {
   u32 debug, mrtdump;			/* Debugging bitfields, both use D_* constants */
   unsigned preference, disabled;	/* Generic parameters */
   u32 router_id;			/* Protocol specific router ID */
+  byte rid_is_random;                   /* Whether or not RID must be generated by a PRNG.
+                                           If this is set to 1, config parser will set router_id to 0 */
   struct rtable_config *table;		/* Table we're attached to */
   struct filter *in_filter, *out_filter; /* Attached filters */
   struct proto_limit *in_limit;		/* Limit for importing routes from protocol */
@@ -258,7 +260,13 @@ struct proto *proto_get_named(struct symbol *, struct protocol *);
 static inline u32
 proto_get_router_id(struct proto_config *pc)
 {
-  return pc->router_id ? pc->router_id : pc->global->router_id;
+  return pc->router_id;
+}
+
+static inline byte
+proto_get_rid_is_random(struct proto_config *pc)
+{
+  return pc->rid_is_random;
 }
 
 extern list active_proto_list;
diff --git a/proto/ospf/Makefile b/proto/ospf/Makefile
index f90222c..fbe4634 100644
--- a/proto/ospf/Makefile
+++ b/proto/ospf/Makefile
@@ -1,4 +1,4 @@
-source=ospf.c topology.c packet.c hello.c neighbor.c iface.c dbdes.c lsreq.c lsupd.c lsack.c lsalib.c rt.c
+source=ospf.c topology.c packet.c hello.c neighbor.c iface.c dbdes.c lsreq.c lsupd.c lsack.c lsalib.c rt.c $(elsa-sources)
 root-rel=../../
 dir-name=proto/ospf
 
diff --git a/proto/ospf/config.Y b/proto/ospf/config.Y
index 67b0785..0ee997f 100644
--- a/proto/ospf/config.Y
+++ b/proto/ospf/config.Y
@@ -71,6 +71,19 @@ ospf_area_finish(void)
 }
 
 static void
+ospf_proto_start(int class)
+{
+  this_proto = proto_config_new(&proto_ospf, sizeof(struct ospf_config), class);
+  init_list(&OSPF_CFG->area_list);
+  init_list(&OSPF_CFG->vlink_list);
+  OSPF_CFG->rfc1583 = DEFAULT_RFC1583;
+  OSPF_CFG->tick = DEFAULT_OSPFTICK;
+#ifdef OSPFv3
+  OSPF_CFG->dridd = DEFAULT_OSPFDRIDD;
+#endif
+}
+
+static void
 ospf_proto_finish(void)
 {
   struct ospf_config *cf = OSPF_CFG;
@@ -101,6 +114,23 @@ ospf_proto_finish(void)
 
   if (!cf->abr && !EMPTY_LIST(cf->vlink_list))
     cf_error( "Vlinks cannot be used on single area router");
+
+}
+
+static void
+ospf_dridd_start(int b)
+{
+#ifdef OSPFv3
+  OSPF_CFG->dridd = b;
+#else /* OSPFv2 */
+  cf_error( "Duplicate Router ID detection can only be used with IPv6");
+#endif
+}
+
+static void
+ospf_dridd_finish(void)
+{
+  /* FIXME tests needed? */
 }
 
 static inline void
@@ -131,6 +161,7 @@ CF_KEYWORDS(ELIGIBLE, POLL, NETWORKS, HIDDEN, VIRTUAL, CHECK, LINK)
 CF_KEYWORDS(RX, BUFFER, LARGE, NORMAL, STUBNET, HIDDEN, SUMMARY, TAG, EXTERNAL)
 CF_KEYWORDS(WAIT, DELAY, LSADB, ECMP, LIMIT, WEIGHT, NSSA, TRANSLATOR, STABILITY)
 CF_KEYWORDS(GLOBAL, LSID, ROUTER, SELF, INSTANCE, REAL)
+CF_KEYWORDS(DUPLICATE, RID, DETECTION)
 
 %type <t> opttext
 %type <ld> lsadb_args
@@ -139,13 +170,7 @@ CF_GRAMMAR
 
 CF_ADDTO(proto, ospf_proto '}' { ospf_proto_finish(); } )
 
-ospf_proto_start: proto_start OSPF {
-     this_proto = proto_config_new(&proto_ospf, sizeof(struct ospf_config), $1);
-     init_list(&OSPF_CFG->area_list);
-     init_list(&OSPF_CFG->vlink_list);
-     OSPF_CFG->rfc1583 = DEFAULT_RFC1583;
-     OSPF_CFG->tick = DEFAULT_OSPFTICK;
-  }
+ospf_proto_start: proto_start OSPF { ospf_proto_start($1); }
  ;
 
 ospf_proto:
@@ -156,6 +181,7 @@ ospf_proto:
 ospf_proto_item:
    proto_item
  | RFC1583COMPAT bool { OSPF_CFG->rfc1583 = $2; }
+ | ospf_dridd
  | ECMP bool { OSPF_CFG->ecmp = $2 ? DEFAULT_ECMP_LIMIT : 0; }
  | ECMP bool LIMIT expr { OSPF_CFG->ecmp = $2 ? $4 : 0; if ($4 < 0) cf_error("ECMP limit cannot be negative"); }
  | TICK expr { OSPF_CFG->tick = $2; if($2<=0) cf_error("Tick must be greater than zero"); }
@@ -353,7 +379,6 @@ ipa_ne: IPA ELIGIBLE ';'
  }
 ;
 
- 
 ospf_iface_start:
  {
   this_ipatt = cfg_allocz(sizeof(struct ospf_iface_patt));
@@ -394,6 +419,26 @@ ospf_iface:
   ospf_iface_start iface_patt_list ospf_instance_id ospf_iface_opt_list { ospf_iface_finish(); }
  ;
 
+ospf_dridd:
+   ospf_dridd_start '{' ospf_dridd_opts '}' { ospf_dridd_finish(); }
+ | ospf_dridd_start { ospf_dridd_finish(); }
+ ;
+
+ospf_dridd_start: DUPLICATE RID DETECTION bool
+ {
+  ospf_dridd_start($4);
+ }
+;
+
+ospf_dridd_opts:
+   /* empty */
+ | ospf_dridd_opts ospf_dridd_item ';'
+ ;
+
+ospf_dridd_item:
+  /* empty for the moment */
+;
+
 opttext:
     TEXT
  | /* empty */ { $$ = NULL; }
@@ -439,7 +484,7 @@ lsadb_args:
      $$ = cfg_allocz(sizeof(struct lsadb_show_data));
    }
  | lsadb_args GLOBAL { $$ = $1; $$->scope = LSA_SCOPE_AS; }
- | lsadb_args AREA idval { $$ = $1; $$->scope = LSA_SCOPE_AREA; $$->area = $3 }
+ | lsadb_args AREA idval { $$ = $1; $$->scope = LSA_SCOPE_AREA; $$->area = $3; }
  | lsadb_args LINK { $$ = $1; $$->scope = 1; /* hack, 0 is no filter */ }
  | lsadb_args TYPE NUM { $$ = $1; $$->type = $3; }
  | lsadb_args LSID idval { $$ = $1; $$->lsid = $3; }
diff --git a/proto/ospf/elsa.c b/proto/ospf/elsa.c
new file mode 100644
index 0000000..fa9def2
--- /dev/null
+++ b/proto/ospf/elsa.c
@@ -0,0 +1,131 @@
+/*
+ * $Id: elsa.c $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *
+ * Copyright (c) 2012 cisco Systems, Inc.
+ *
+ * Created:       Wed Aug  1 14:01:30 2012 mstenber
+ * Last modified: Wed Oct 24 13:22:06 2012 mstenber
+ * Edit time:     57 min
+ *
+ */
+
+#include <stdlib.h>
+
+#include "elsa_internal.h"
+#include "lauxlib.h"
+#include "lualib.h"
+
+extern int luaopen_elsac(lua_State* L);
+
+elsa elsa_create(elsa_client client)
+{
+  elsa e;
+  int r;
+
+  e = elsai_calloc(client, sizeof(*e));
+  e->client = client;
+  e->l = luaL_newstate();
+  luaL_openlibs(e->l);
+  luaopen_elsac(e->l);
+  if ((r = luaL_loadfile(e->l, "elsa.lua")) ||
+      (r = lua_pcall(e->l, 0, 0, 0))
+      )
+    {
+      ELSA_ERROR("error %d in lua init: %s", r, lua_tostring(e->l, -1));
+      lua_pop(e->l, 1);
+      // is this fatal? hmm
+      abort();
+    }
+
+  ELSA_DEBUG("created elsa %p for client %p", e, client);
+  return e;
+}
+
+void elsa_destroy(elsa e)
+{
+  lua_close(e->l);
+  elsai_free(e->client, e);
+  ELSA_DEBUG("destroyed elsa %p", e);
+}
+
+/* LUA-specific magic - this way we don't need to worry about encoding
+ * the elsa correctly as elsa_dispatch parameter. */
+static elsa active_elsa;
+
+void elsa_dispatch(elsa e)
+{
+  int r;
+
+  active_elsa = e;
+  /* Call LUA */
+  lua_getglobal(e->l, "elsa_dispatch");
+  //lua_pushlightuserdata(e->l, (void *)e);
+  //SWIG_Lua_NewPointerObj(e->l,e,SWIGTYPE_p_elsa_struct,0)
+
+  if ((r = lua_pcall(e->l, 0, 0, 0)))
+    {
+      ELSA_ERROR("error %d in LUA lua_pcall: %s", r, lua_tostring(e->l, -1));
+      lua_pop(e->l, 1);
+      // is this fatal? hmm
+      abort();
+    }
+  active_elsa = NULL;
+}
+
+elsa elsa_active_get(void)
+{
+  return active_elsa;
+}
+
+/* LUA-specific magic - this way we don't need to worry about encoding
+ * the elsa correctly as elsa_duplicate_lsa_dispatch parameter. */
+static elsa_lsa active_elsa_lsa;
+
+static void dispatch_lsa_callback(elsa e, elsa_lsa lsa, const char *cb_name)
+{
+  int r;
+
+  active_elsa = e;
+  active_elsa_lsa = lsa;
+  /* Call LUA */
+  lua_getglobal(e->l, cb_name);
+  //lua_pushlightuserdata(e->l, (void *)e);
+  //SWIG_Lua_NewPointerObj(e->l,e,SWIGTYPE_p_elsa_struct,0)
+
+  if ((r = lua_pcall(e->l, 0, 0, 0)))
+    {
+      ELSA_ERROR("error %d in LUA lua_pcall: %s", r, lua_tostring(e->l, -1));
+      lua_pop(e->l, 1);
+      // is this fatal? hmm
+      abort();
+    }
+  active_elsa = NULL;
+  active_elsa_lsa = NULL;
+}
+
+void elsa_notify_changed_lsa(elsa e, elsa_lsa lsa)
+{
+  dispatch_lsa_callback(e, lsa, "elsa_notify_changed_lsa");
+}
+
+void elsa_notify_deleting_lsa(elsa e, elsa_lsa lsa)
+{
+  dispatch_lsa_callback(e, lsa, "elsa_notify_deleting_lsa");
+}
+
+void elsa_notify_duplicate_lsa(elsa e, elsa_lsa lsa)
+{
+  dispatch_lsa_callback(e, lsa, "elsa_notify_duplicate_lsa");
+}
+
+elsa_lsa elsa_active_lsa_get(void)
+{
+  return active_elsa_lsa;
+}
+
+void elsa_log_string(const char *string)
+{
+  log(L_TRACE "%s", string);
+}
diff --git a/proto/ospf/elsa.h b/proto/ospf/elsa.h
new file mode 100644
index 0000000..d4f891d
--- /dev/null
+++ b/proto/ospf/elsa.h
@@ -0,0 +1,170 @@
+/*
+ * $Id: elsa.h $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *
+ * Copyright (c) 2012 cisco Systems, Inc.
+ *
+ * Created:       Wed Aug  1 13:31:21 2012 mstenber
+ * Last modified: Wed Oct 24 13:21:49 2012 mstenber
+ * Edit time:     86 min
+ *
+ */
+
+/* TODO:
+ *
+ * - consider the LSA body+data handling semantics - non-copying
+ * ones might be nice to have.
+ */
+
+#ifndef ELSA_H
+#define ELSA_H
+
+/*
+ * Public bidirectional interface to the external-LSA code.
+ *
+ * elsa_* calls are called by the client application.
+ *
+ * elsai_* calls are called by ELSA code which wants the platform code
+ * to do something.
+ *
+ * General design criteria is that the data in network format should
+ * be usable directly; however, individual VALUES we move across
+ * should be in host order.
+ * - LSA payload is in network order
+ * - individual LSA fields (e.g.) that are passed through API are in host order
+ */
+
+/* Whoever includes this file should provide the appropriate
+ * definitions for the structures involved. The ELSA code treats them
+ * as opaque. */
+#include "elsa_platform.h"
+/* e.g.
+   typedef .. my stuff *elsa_client;
+   typedef .. *elsa_lsa;
+   typedef .. *elsa_if;
+   typedef .. *elsa_ac_usp;
+   ( typesafety is mandatory).
+ */
+
+
+/* Only externally visible pointer elsa itself provides. */
+typedef struct elsa_struct *elsa;
+typedef unsigned short elsa_lsatype;
+
+/******************************************* outside world -> ELSA interface */
+
+/* Create an ELSA instance. NULL is returned in case of an error. */
+elsa elsa_create(elsa_client client);
+
+/* Change notifications */
+void elsa_notify_changed_lsa(elsa e, elsa_lsa lsa);
+void elsa_notify_deleting_lsa(elsa e, elsa_lsa lsa);
+
+/* Notify ELSA when duplicate LSA has been received. */
+void elsa_notify_duplicate_lsa(elsa e, elsa_lsa lsa);
+
+/* Dispatch ELSA action - should be called once a second (or so). */
+void elsa_dispatch(elsa e);
+
+/* Destroy an ELSA instance. */
+void elsa_destroy(elsa e);
+
+/******************************************* ELSA -> outside world interface */
+
+/* Allocate a block of memory. The memory should be zeroed. */
+void *elsai_calloc(elsa_client client, size_t size);
+
+/* Free a block of memory. */
+void elsai_free(elsa_client client, void *ptr);
+
+
+/* Get current router ID. */
+uint32_t elsai_get_rid(elsa_client client);
+
+/* (Try to) change the router ID of the router. */
+void elsai_change_rid(elsa_client client);
+
+/* Get route to the rid; returned next-hop address + if (NULL if no
+   route). */
+void elsai_route_to_rid(elsa_client client, uint32_t rid,
+                        char **output_nh, char **output_if);
+
+/**************************************************** LSA handling interface */
+
+/* Originate LSA.
+
+   rid is implicitly own router ID.
+   age/area is implicitly zero.
+*/
+void elsai_lsa_originate(elsa_client client,
+                         elsa_lsatype lsatype,
+                         uint32_t lsid,
+                         uint32_t sn,
+                         const unsigned char *body, size_t body_len);
+
+/* Get first LSA by type. */
+elsa_lsa elsai_get_lsa_by_type(elsa_client client, elsa_lsatype lsatype);
+
+/* Get next LSA by type. */
+elsa_lsa elsai_get_lsa_by_type_next(elsa_client client, elsa_lsa lsa);
+
+/* Getters */
+elsa_lsatype elsai_lsa_get_type(elsa_lsa lsa);
+uint32_t elsai_lsa_get_rid(elsa_lsa lsa);
+uint32_t elsai_lsa_get_lsid(elsa_lsa lsa);
+void elsai_lsa_get_body(elsa_lsa lsa, unsigned char **body, size_t *body_len);
+
+/******************************************************** Interface handling */
+
+/* Get interface */
+elsa_if elsai_if_get(elsa_client client);
+
+/* Get next interface */
+elsa_if elsai_if_get_next(elsa_client client, elsa_if ifp);
+
+/* Assorted getters */
+
+const char * elsai_if_get_name(elsa_client client, elsa_if i);
+uint32_t elsai_if_get_index(elsa_client client, elsa_if i);
+uint8_t elsai_if_get_priority(elsa_client client, elsa_if i);
+
+/* Get first neighbor */
+elsa_neigh elsai_if_get_neigh(elsa_client client, elsa_if i);
+
+/********************************************************* Neighbor handling */
+uint32_t elsai_neigh_get_rid(elsa_client client, elsa_neigh neigh);
+uint32_t elsai_neigh_get_iid(elsa_client client, elsa_neigh neigh);
+
+/* Get next neighbor (in list) */
+elsa_neigh elsai_neigh_get_next(elsa_client client, elsa_neigh neigh);
+
+/****************************************************** Debugging / tracing  */
+
+#define ELSA_DEBUG_LEVEL_ERROR 1
+#define ELSA_DEBUG_LEVEL_INFO 2
+#define ELSA_DEBUG_LEVEL_DEBUG 3
+
+/* Get the debug level */
+int elsai_get_log_level(void);
+/* void elsai_log(const char *file, int line, int level, const char *fmt, ...); */
+
+#define ELSA_LOG(l,fmt...)                      \
+do {                                            \
+  if (elsai_get_log_level() >= l) {             \
+    elsai_log(__FILE__, __LINE__, l, ##fmt);    \
+  }                                             \
+ } while(0)
+
+#define ELSA_ERROR(fmt...) ELSA_LOG(ELSA_DEBUG_LEVEL_ERROR, ##fmt)
+#define ELSA_INFO(fmt...) ELSA_LOG(ELSA_DEBUG_LEVEL_INFO, ##fmt)
+#define ELSA_DEBUG(fmt...) ELSA_LOG(ELSA_DEBUG_LEVEL_DEBUG, ##fmt)
+
+/************************************************************ 'Other stuff'  */
+
+/* LUA cruft */
+elsa elsa_active_get(void);
+elsa_lsa elsa_active_lsa_get(void);
+void elsa_log_string(const char *string);
+
+#endif /* ELSA_H */
diff --git a/proto/ospf/elsa.i b/proto/ospf/elsa.i
new file mode 100644
index 0000000..b5b8bc4
--- /dev/null
+++ b/proto/ospf/elsa.i
@@ -0,0 +1,91 @@
+//
+// Author: Markus Stenberg <fingon@iki.fi>
+//
+// Copyright (c) 2012 cisco Systems, Inc.
+//
+
+%module elsac
+%include "typemaps.i"
+
+%{
+#include "elsa.h"
+#include "elsa_internal.h"
+%}
+
+// C input binary buffers
+%typemap(in, numinputs=1) (const unsigned char *body, size_t body_len) {
+  if(!lua_isstring(L,$input)) SWIG_fail_arg("???",$input,"<lua string>");
+  $1 = (unsigned char *)lua_tolstring(L, $input, &$2);
+}
+
+// C output binary buffers
+%typemap(in, numinputs=0) (unsigned char **body, size_t *body_len) (unsigned char *b, size_t bs) {
+  $1 = &b;
+  $2 = &bs;
+ }
+
+%typemap(argout) (unsigned char **body, size_t *body_len) {
+  lua_pushlstring(L, *$1, *$2); SWIG_arg++;
+}
+
+
+// C output nh+ifname
+
+%typemap(in, numinputs=0) (char **output_nh, char **output_if) (char *nh, char *ifname) {
+  $1 = &nh;
+  $2 = &ifname;
+ }
+
+
+%typemap(argout) (char **output_nh, char **output_if) {
+  if (*$1 && *$2)
+    {
+      lua_pushlstring(L, *$1, strlen(*$1)); SWIG_arg++;
+      lua_pushlstring(L, *$2, strlen(*$2)); SWIG_arg++;
+    }
+}
+
+
+ /* Stuff to make it behave sanely */
+typedef unsigned int uint32_t;
+typedef unsigned char uint8_t;
+
+/* from ospf.h */
+#define LSA_T_RT	0x2001
+#define LSA_T_NET	0x2002
+#define LSA_T_SUM_NET	0x2003
+#define LSA_T_SUM_RT	0x2004
+#define LSA_T_EXT	0x4005
+#define LSA_T_NSSA	0x2007
+#define LSA_T_LINK	0x0008
+#define LSA_T_PREFIX	0x2009
+
+ /* From elsa_platform.h */
+
+/* BIRD-specific ELSA platform definitions. */
+typedef struct proto_ospf *elsa_client;
+
+/* Opaque LSA blob that doesn't quite have equivalent in BIRD. */
+typedef struct elsa_lsa_struct *elsa_lsa;
+
+/* Opaque IF blob. */
+typedef struct ospf_iface *elsa_if;
+
+/* Opaque neighbor blob. */
+typedef struct ospf_neighbor *elsa_neigh;
+
+/* Opaque USP blob. */
+typedef struct elsa_usp_struct *elsa_ac_usp;
+
+
+/* Only externally visible pointer elsa itself provides. */
+typedef struct elsa_struct *elsa;
+
+typedef unsigned short elsa_lsatype;
+
+/* AF-wise relevant bits */
+struct elsa_struct {
+  elsa_client client;
+};
+
+%include "elsa.h"
diff --git a/proto/ospf/elsa_internal.h b/proto/ospf/elsa_internal.h
new file mode 100644
index 0000000..fa77d3f
--- /dev/null
+++ b/proto/ospf/elsa_internal.h
@@ -0,0 +1,34 @@
+/*
+ * $Id: elsa_internal.h $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *         Benjamin Paterson <paterson.b@gmail.com>
+ *
+ * Copyright (c) 2012 cisco Systems, Inc.
+ *
+ * Created:       Wed Aug  1 14:23:23 2012 mstenber
+ * Last modified: Wed Oct 24 13:21:53 2012 mstenber
+ * Edit time:     17 min
+ *
+ */
+
+#ifndef ELSA_INTERNAL_H
+#define ELSA_INTERNAL_H
+
+#include <assert.h>
+#include <lua.h>
+
+#include "elsa.h"
+
+struct elsa_struct {
+  elsa_client client;
+
+  struct elsa_platform_struct platform;
+
+  lua_State *l;
+
+  unsigned char buf[65536];
+  unsigned char *tail;
+};
+
+#endif /* ELSA_INTERNAL_H */
diff --git a/proto/ospf/elsa_platform.c b/proto/ospf/elsa_platform.c
new file mode 100644
index 0000000..d17d015
--- /dev/null
+++ b/proto/ospf/elsa_platform.c
@@ -0,0 +1,375 @@
+/*
+ * $Id: elsa_platform.c $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *
+ * Copyright (c) 2012 cisco Systems, Inc.
+ *
+ * Created:       Wed Aug  1 14:14:38 2012 mstenber
+ * Last modified: Wed Oct 24 13:22:10 2012 mstenber
+ * Edit time:     112 min
+ *
+ */
+
+#include "ospf.h"
+#include "elsa.h"
+#include "elsa_internal.h"
+
+#include <assert.h>
+
+#include "lib/md5.h"
+
+/********************************************************** Memory handling  */
+
+void *elsai_calloc(elsa_client client, size_t size)
+{
+  struct proto *p = &client->proto;
+  void *t = mb_allocz(p->pool, size);
+  return t;
+}
+
+void elsai_free(elsa_client client, void *ptr)
+{
+  mb_free(ptr);
+}
+
+/*************************************************************** General API */
+
+uint32_t elsai_get_rid(elsa_client client)
+{
+  return client->router_id;
+}
+
+void ospf_dridd_trigger(struct proto_ospf *po);
+
+void elsai_change_rid(elsa_client client)
+{
+  ospf_dridd_trigger(client);
+}
+
+/* Sigh.. cut-n-pate from rt.c */
+#ifdef OSPFv2
+#define ipa_from_rid(x) _MI(x)
+#else /* OSPFv3 */
+#define ipa_from_rid(x) _MI(0,0,0,x)
+#endif
+
+void elsai_route_to_rid(elsa_client client, uint32_t rid,
+                        char **output_nh, char **output_if)
+{
+  /* There seems to be two (bad) solutions to this. First one doesn't
+     work without changes to rt.c, second one works but shouldn't
+     (according to code comments). */
+#if 0
+  /* This uses rt.c internal data structures, and can't work -
+     the structures are cleared at end of calculation. */
+  struct ospf_area *area = ospf_find_area(client, 0);
+  ip_addr addr = ipa_from_rid(rid);
+  ort *r = (ort *)fib_find(&area->rtr, &addr, MAX_PREFIX_LENGTH);
+  /* ~maximum is 2+1 * 8 = ~24 bytes */
+  static char nh_buf[25];
+
+  *output_nh = NULL;
+  *output_if = NULL;
+  ELSA_DEBUG("elsai_route_to_rid %x got %p %p %p",
+             rid,
+             r,
+             r ? r->n.nhs : NULL,
+             r && r->n.nhs ? r->n.nhs->iface : NULL);
+  if (r && r->n.nhs && r->n.nhs->iface)
+    {
+      ip_ntop(r->n.nhs->gw, nh_buf);
+      *output_nh = nh_buf;
+      *output_if = r->n.nhs->iface->name;
+    }
+#else
+  /* This uses topology.[ch] API, which is reasonable choice, but
+     code comment says ->nhs is valid only during SPF calculation. This
+     isn't, strictly speaking, true, at the moment. */
+  struct top_hash_entry *en = ospf_hash_find_rt(client->gr, 0, rid);
+  /* ~maximum is 2+1 * 8 = ~24 bytes */
+  static char nh_buf[25];
+
+  *output_nh = NULL;
+  *output_if = NULL;
+  ELSA_DEBUG("elsai_route_to_rid %x got %p %p %p",
+             rid,
+             en,
+             en ? en->nhs : NULL,
+             en && en->nhs ? en->nhs->iface : NULL);
+  if (en && en->nhs && en->nhs->iface)
+    {
+      ip_ntop(en->nhs->gw, nh_buf);
+      *output_nh = nh_buf;
+      *output_if = en->nhs->iface->name;
+    }
+#endif /* 0 */
+}
+
+/************************************************************** LSA handling */
+
+uint32_t elsai_lsa_get_rid(elsa_lsa lsa)
+{
+  struct top_hash_entry *en = lsa->hash_entry;
+
+  assert(en);
+  return en->lsa.rt;
+}
+
+
+elsa_lsatype elsai_lsa_get_type(elsa_lsa lsa)
+{
+  struct top_hash_entry *en = lsa->hash_entry;
+
+  assert(en);
+  return en->lsa.type;
+}
+
+uint32_t elsai_lsa_get_lsid(elsa_lsa lsa)
+{
+  struct top_hash_entry *en = lsa->hash_entry;
+
+  assert(en);
+  return en->lsa.id;
+}
+
+void elsai_lsa_get_body(elsa_lsa lsa, unsigned char **body, size_t *body_len)
+{
+  struct top_hash_entry *en = lsa->hash_entry;
+  int len;
+
+  assert(en);
+  len = en->lsa.length - sizeof(struct ospf_lsa_header);
+  if (lsa->swapped)
+    {
+      htonlsab(en->lsa_body, lsa->dummy_lsa_buf, len);
+      *body = (void *)lsa->dummy_lsa_buf;
+    }
+  else
+    {
+      *body = en->lsa_body;
+    }
+  *body_len = len;
+}
+
+static elsa_lsa find_next_entry(elsa_client client,
+                                elsa_lsa lsa,
+                                elsa_lsatype type)
+{
+  int i;
+  struct top_graph *gr = client->gr;
+  struct top_hash_entry *e;
+  for (i = lsa->hash_bin ; i < gr->hash_size ; i++)
+    if ((e=gr->hash_table[i]))
+      {
+        while (e)
+          {
+            if (e->lsa.type != type)
+              {
+                e = e->next;
+                continue;
+              }
+            lsa->hash_entry = e;
+            lsa->swapped = true;
+            lsa->hash_bin = i;
+            return lsa;
+          }
+      }
+  return NULL;
+}
+
+elsa_lsa elsai_get_lsa_by_type(elsa_client client, elsa_lsatype lsatype)
+{
+  int idx =
+    client->elsa->platform.last_lsa++ % SUPPORTED_SIMULTANEOUS_LSA_ITERATIONS;
+  elsa_lsa lsa =
+    &client->elsa->platform.lsa[idx];
+  lsa->hash_bin = 0;
+  lsa->hash_entry = NULL;
+  return find_next_entry(client, lsa, lsatype);
+}
+
+elsa_lsa elsai_get_lsa_by_type_next(elsa_client client, elsa_lsa lsa)
+{
+  elsa_lsatype type;
+
+  assert(lsa->hash_entry);
+  type = lsa->hash_entry->lsa.type;
+  while (lsa->hash_entry->next)
+    {
+      lsa->hash_entry = lsa->hash_entry->next;
+      /* lsa->swapped = true; - should be already! */
+      if (lsa->hash_entry->lsa.type == type)
+          return lsa;
+    }
+  lsa->hash_bin++;
+  return find_next_entry(client, lsa, type);
+}
+
+/*************************************************************** IF handling */
+
+elsa_if elsai_if_get(elsa_client client)
+{
+  /* Should be just 1 area, but hell.. :-) */
+  elsa_if i = HEAD(client->iface_list);
+  if (!NODE_VALID(i))
+    i = NULL;
+  /* ELSA_DEBUG("elsai_if_get %p", i); */
+  return i;
+}
+
+const char *elsai_if_get_name(elsa_client client, elsa_if i)
+{
+  if (!i->iface)
+    return NULL;
+
+  return i->iface->name;
+}
+
+
+uint32_t elsai_if_get_index(elsa_client client, elsa_if i)
+{
+  if (!i->iface)
+    return 0;
+
+  return i->iface->index;
+}
+
+uint8_t elsai_if_get_priority(elsa_client client, elsa_if i)
+{
+  /* XXX - someday put interface config back in? */
+  return 50;
+}
+
+elsa_if elsai_if_get_next(elsa_client client, elsa_if ifp)
+{
+  elsa_if i = NODE_NEXT(ifp);
+  if (!NODE_VALID(i))
+    i = NULL;
+  /* ELSA_DEBUG("elsai_if_get_next %p => %p", ifp, i); */
+  return i;
+}
+
+/********************************************************* Neighbor handling */
+
+elsa_neigh elsai_if_get_neigh(elsa_client client, elsa_if i)
+{
+  elsa_neigh n = HEAD(i->neigh_list);
+
+  if (!NODE_VALID(n))
+    return NULL;
+  while (NODE_VALID(n) && n->state < NEIGHBOR_INIT)
+    n = NODE_NEXT(n);
+  if (NODE_VALID(n) && n->state >= NEIGHBOR_INIT)
+    return n;
+  return NULL;
+}
+
+uint32_t elsai_neigh_get_rid(elsa_client client, elsa_neigh neigh)
+{
+  return neigh->rid;
+}
+
+uint32_t elsai_neigh_get_iid(elsa_client client, elsa_neigh neigh)
+{
+#ifdef OSPFv3
+  return neigh->iface_id;
+#else
+  return 0;
+#endif
+}
+
+elsa_neigh elsai_neigh_get_next(elsa_client client, elsa_neigh neigh)
+{
+  elsa_neigh n = NODE_NEXT(neigh);
+
+  while (NODE_VALID(n) && n->state < NEIGHBOR_INIT)
+    n = NODE_NEXT(n);
+  if (NODE_VALID(n) && n->state >= NEIGHBOR_INIT)
+    return n;
+  return NULL;
+}
+
+
+
+/*************************************************************** Other stuff */
+
+
+
+void elsai_lsa_originate(elsa_client client,
+                         elsa_lsatype lsatype,
+                         uint32_t lsid,
+                         uint32_t sn,
+                         const unsigned char *body, size_t body_len)
+{
+  struct ospf_lsa_header lsa;
+  void *tmp;
+
+  tmp = mb_alloc(client->proto.pool, body_len);
+  if (!tmp)
+    return;
+  lsa.age = 0;
+#if 0
+  lsa.type = ntohs(lsatype);
+  lsa.id = ntohl(lsid);
+  lsa.sn = ntohl(sn);
+#else
+  lsa.type = lsatype;
+  lsa.id = lsid;
+  lsa.sn = sn;
+#endif /* 0 */
+  lsa.rt = client->router_id;
+  uint32_t dom = 0;
+  lsa.length = body_len + sizeof(struct ospf_lsa_header);
+
+  ntohlsab((void *)body, tmp, body_len);
+  lsasum_calculate(&lsa, (void *)tmp);
+
+  (void)lsa_install_new(client, &lsa, dom, tmp);
+
+  ospf_lsupd_flood(client, NULL, NULL, &lsa, dom, 1);
+}
+
+/*************************************************** Configured USP handling */
+
+elsa_ac_usp elsai_ac_usp_get(elsa_client client)
+{
+  /* XXX */
+  return NULL;
+}
+
+/* Get next available usable prefix */
+elsa_ac_usp elsai_ac_usp_get_next(elsa_client client, elsa_ac_usp usp)
+{
+  /* XXX */
+  return NULL;
+}
+
+/* Get the prefix's contents. The result_size is the size of result in bits,
+ * and result pointer itself points at the prefix data. */
+void elsai_ac_usp_get_prefix(elsa_client client, elsa_ac_usp usp,
+                             void **result, int *result_size_bits)
+{
+  *result = NULL;
+  *result_size_bits = 0;
+}
+
+/***************************************************************** Debugging */
+
+int elsai_get_log_level(void)
+{
+  return ELSA_DEBUG_LEVEL_DEBUG;
+}
+
+/********************************************************* Platform-specific */
+
+elsa_lsa elsa_platform_wrap_lsa(elsa_client client,
+                                struct top_hash_entry *lsa)
+{
+  int idx = client->elsa->platform.last_lsa++
+    % SUPPORTED_SIMULTANEOUS_LSA_ITERATIONS;
+  elsa_lsa l = &client->elsa->platform.lsa[idx];
+  l->swapped = false;
+  l->hash_entry = lsa;
+  return l;
+}
diff --git a/proto/ospf/elsa_platform.h b/proto/ospf/elsa_platform.h
new file mode 100644
index 0000000..dd700d0
--- /dev/null
+++ b/proto/ospf/elsa_platform.h
@@ -0,0 +1,76 @@
+/*
+ * $Id: elsa_platform.h $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *
+ * Copyright (c) 2012 cisco Systems, Inc.
+ *
+ * Created:       Wed Aug  1 14:09:11 2012 mstenber
+ * Last modified: Wed Oct 24 13:21:57 2012 mstenber
+ * Edit time:     17 min
+ *
+ */
+
+#ifndef ELSA_PLATFORM_H
+#define ELSA_PLATFORM_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#define SUPPORTED_SIMULTANEOUS_LSA_ITERATIONS 4
+
+/* BIRD-specific ELSA platform definitions. */
+typedef struct proto_ospf *elsa_client;
+
+/* Opaque LSA blob that doesn't quite have equivalent in BIRD. */
+typedef struct elsa_lsa_struct *elsa_lsa;
+
+/* Opaque IF blob. */
+typedef struct ospf_iface *elsa_if;
+
+/* Opaque neighbor blob. */
+typedef struct ospf_neighbor *elsa_neigh;
+
+/* Opaque USP blob. */
+typedef struct elsa_usp_struct *elsa_ac_usp;
+
+/* MD5 context (dynamically allocated) */
+typedef struct MD5Context *elsa_md5;
+
+struct elsa_lsa_struct {
+  int hash_bin;
+  bool swapped; /* is it swapped to host order? if so, we must reverse it*/
+  struct top_hash_entry *hash_entry;
+  unsigned char dummy_lsa_buf[65540];
+};
+
+
+struct elsa_platform_struct {
+  /* Buffer we use for reversing the pain that is BIRD -
+   * the handling of byte-aligned big/little endian stuff differently
+   * based on the underlying platform is just herecy.
+   *
+   * It makes struct definitions for one look rather .. odd.
+   */
+
+  /* We support also only X LSA iterations at a time. */
+  int last_lsa;
+
+  struct elsa_lsa_struct lsa[SUPPORTED_SIMULTANEOUS_LSA_ITERATIONS];
+};
+
+#include "nest/bird.h"
+
+#define elsai_log(file,line,level,fmt,...)                      \
+do {                                                            \
+  /* XXX - care about the 'level'! */                           \
+  log(L_TRACE "%s:%d " fmt, file, line, ## __VA_ARGS__);        \
+ } while (0)
+
+#undef net_in_net
+
+elsa_lsa elsa_platform_wrap_lsa(elsa_client client,
+                                struct top_hash_entry *lsa);
+
+#endif /* ELSA_PLATFORM_H */
diff --git a/proto/ospf/elsa_wrap.c b/proto/ospf/elsa_wrap.c
new file mode 100644
index 0000000..e7a825a
--- /dev/null
+++ b/proto/ospf/elsa_wrap.c
@@ -0,0 +1,3053 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.4
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGLUA
+#define SWIG_LUA_MODULE_GLOBAL
+
+/* -----------------------------------------------------------------------------
+ *  This section contains generic SWIG labels for method/variable
+ *  declarations/attributes, and other compiler dependent labels.
+ * ----------------------------------------------------------------------------- */
+
+/* template workaround for compilers that cannot correctly implement the C++ standard */
+#ifndef SWIGTEMPLATEDISAMBIGUATOR
+# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# else
+#  define SWIGTEMPLATEDISAMBIGUATOR
+# endif
+#endif
+
+/* inline attribute */
+#ifndef SWIGINLINE
+# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+#   define SWIGINLINE inline
+# else
+#   define SWIGINLINE
+# endif
+#endif
+
+/* attribute recognised by some compilers to avoid 'unused' warnings */
+#ifndef SWIGUNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define SWIGUNUSED __attribute__ ((__unused__)) 
+#   else
+#     define SWIGUNUSED
+#   endif
+# elif defined(__ICC)
+#   define SWIGUNUSED __attribute__ ((__unused__)) 
+# else
+#   define SWIGUNUSED 
+# endif
+#endif
+
+#ifndef SWIG_MSC_UNSUPPRESS_4505
+# if defined(_MSC_VER)
+#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+# endif 
+#endif
+
+#ifndef SWIGUNUSEDPARM
+# ifdef __cplusplus
+#   define SWIGUNUSEDPARM(p)
+# else
+#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+# endif
+#endif
+
+/* internal SWIG method */
+#ifndef SWIGINTERN
+# define SWIGINTERN static SWIGUNUSED
+#endif
+
+/* internal inline SWIG method */
+#ifndef SWIGINTERNINLINE
+# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+#endif
+
+/* exporting methods */
+#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#  ifndef GCC_HASCLASSVISIBILITY
+#    define GCC_HASCLASSVISIBILITY
+#  endif
+#endif
+
+#ifndef SWIGEXPORT
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   if defined(STATIC_LINKED)
+#     define SWIGEXPORT
+#   else
+#     define SWIGEXPORT __declspec(dllexport)
+#   endif
+# else
+#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+#     define SWIGEXPORT __attribute__ ((visibility("default")))
+#   else
+#     define SWIGEXPORT
+#   endif
+# endif
+#endif
+
+/* calling conventions for Windows */
+#ifndef SWIGSTDCALL
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   define SWIGSTDCALL __stdcall
+# else
+#   define SWIGSTDCALL
+# endif 
+#endif
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * swigrun.swg
+ *
+ * This file contains generic C API SWIG runtime support for pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+/* This should only be incremented when either the layout of swig_type_info changes,
+   or for whatever reason, the runtime changes incompatibly */
+#define SWIG_RUNTIME_VERSION "4"
+
+/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+#ifdef SWIG_TYPE_TABLE
+# define SWIG_QUOTE_STRING(x) #x
+# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+#else
+# define SWIG_TYPE_TABLE_NAME
+#endif
+
+/*
+  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+  creating a static or dynamic library from the SWIG runtime code.
+  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
+  
+  But only do this if strictly necessary, ie, if you have problems
+  with your compiler or suchlike.
+*/
+
+#ifndef SWIGRUNTIME
+# define SWIGRUNTIME SWIGINTERN
+#endif
+
+#ifndef SWIGRUNTIMEINLINE
+# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+#endif
+
+/*  Generic buffer size */
+#ifndef SWIG_BUFFER_SIZE
+# define SWIG_BUFFER_SIZE 1024
+#endif
+
+/* Flags for pointer conversions */
+#define SWIG_POINTER_DISOWN        0x1
+#define SWIG_CAST_NEW_MEMORY       0x2
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_OWN           0x1
+
+
+/* 
+   Flags/methods for returning states.
+   
+   The SWIG conversion methods, as ConvertPtr, return an integer 
+   that tells if the conversion was successful or not. And if not,
+   an error code can be returned (see swigerrors.swg for the codes).
+   
+   Use the following macros/flags to set or process the returning
+   states.
+   
+   In old versions of SWIG, code such as the following was usually written:
+
+     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+       // success code
+     } else {
+       //fail code
+     }
+
+   Now you can be more explicit:
+
+    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+    } else {
+      // fail code
+    }
+
+   which is the same really, but now you can also do
+
+    Type *ptr;
+    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+      if (SWIG_IsNewObj(res) {
+        ...
+	delete *ptr;
+      } else {
+        ...
+      }
+    } else {
+      // fail code
+    }
+    
+   I.e., now SWIG_ConvertPtr can return new objects and you can
+   identify the case and take care of the deallocation. Of course that
+   also requires SWIG_ConvertPtr to return new result values, such as
+
+      int SWIG_ConvertPtr(obj, ptr,...) {         
+        if (<obj is ok>) {			       
+          if (<need new object>) {		       
+            *ptr = <ptr to new allocated object>; 
+            return SWIG_NEWOBJ;		       
+          } else {				       
+            *ptr = <ptr to old object>;	       
+            return SWIG_OLDOBJ;		       
+          } 				       
+        } else {				       
+          return SWIG_BADOBJ;		       
+        }					       
+      }
+
+   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+   SWIG errors code.
+
+   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+   allows to return the 'cast rank', for example, if you have this
+
+       int food(double)
+       int fooi(int);
+
+   and you call
+ 
+      food(1)   // cast rank '1'  (1 -> 1.0)
+      fooi(1)   // cast rank '0'
+
+   just use the SWIG_AddCast()/SWIG_CheckState()
+*/
+
+#define SWIG_OK                    (0) 
+#define SWIG_ERROR                 (-1)
+#define SWIG_IsOK(r)               (r >= 0)
+#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+
+/* The CastRankLimit says how many bits are used for the cast rank */
+#define SWIG_CASTRANKLIMIT         (1 << 8)
+/* The NewMask denotes the object was created (using new/malloc) */
+#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+/* The TmpMask is for in/out typemaps that use temporal objects */
+#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+/* Simple returning values */
+#define SWIG_BADOBJ                (SWIG_ERROR)
+#define SWIG_OLDOBJ                (SWIG_OK)
+#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+/* Check, add and del mask methods */
+#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+
+/* Cast-Rank Mode */
+#if defined(SWIG_CASTRANK_MODE)
+#  ifndef SWIG_TypeRank
+#    define SWIG_TypeRank             unsigned long
+#  endif
+#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+#    define SWIG_MAXCASTRANK          (2)
+#  endif
+#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+}
+SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+}
+#else /* no cast-rank mode */
+#  define SWIG_AddCast
+#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+#endif
+
+
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *(*swig_converter_func)(void *, int *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+/* Structure to store information on one type */
+typedef struct swig_type_info {
+  const char             *name;			/* mangled name of this type */
+  const char             *str;			/* human readable name of this type */
+  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+  void                   *clientdata;		/* language specific type data */
+  int                    owndata;		/* flag if the structure owns the clientdata */
+} swig_type_info;
+
+/* Structure to store a type and conversion function used for casting */
+typedef struct swig_cast_info {
+  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+  swig_converter_func     converter;		/* function to cast the void pointers */
+  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+  struct swig_cast_info  *prev;			/* pointer to the previous cast */
+} swig_cast_info;
+
+/* Structure used to store module information
+ * Each module generates one structure like this, and the runtime collects
+ * all of these structures and stores them in a circularly linked list.*/
+typedef struct swig_module_info {
+  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+  size_t                 size;		        /* Number of types in this module */
+  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+  swig_type_info         **type_initial;	/* Array of initially generated type structures */
+  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+  void                    *clientdata;		/* Language specific module data */
+} swig_module_info;
+
+/* 
+  Compare two type names skipping the space characters, therefore
+  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+
+  Return 0 when the two name types are equivalent, as in
+  strncmp, but skipping ' '.
+*/
+SWIGRUNTIME int
+SWIG_TypeNameComp(const char *f1, const char *l1,
+		  const char *f2, const char *l2) {
+  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+    while ((*f1 == ' ') && (f1 != l1)) ++f1;
+    while ((*f2 == ' ') && (f2 != l2)) ++f2;
+    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+  }
+  return (int)((l1 - f1) - (l2 - f2));
+}
+
+/*
+  Check type equivalence in a name list like <name1>|<name2>|...
+  Return 0 if not equal, 1 if equal
+*/
+SWIGRUNTIME int
+SWIG_TypeEquiv(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv && *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+/*
+  Check type equivalence in a name list like <name1>|<name2>|...
+  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+*/
+SWIGRUNTIME int
+SWIG_TypeCompare(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv && *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+
+/*
+  Check the typename
+*/
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+  if (ty) {
+    swig_cast_info *iter = ty->cast;
+    while (iter) {
+      if (strcmp(iter->type->name, c) == 0) {
+        if (iter == ty->cast)
+          return iter;
+        /* Move iter to the top of the linked list */
+        iter->prev->next = iter->next;
+        if (iter->next)
+          iter->next->prev = iter->prev;
+        iter->next = ty->cast;
+        iter->prev = 0;
+        if (ty->cast) ty->cast->prev = iter;
+        ty->cast = iter;
+        return iter;
+      }
+      iter = iter->next;
+    }
+  }
+  return 0;
+}
+
+/* 
+  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
+*/
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
+  if (ty) {
+    swig_cast_info *iter = ty->cast;
+    while (iter) {
+      if (iter->type == from) {
+        if (iter == ty->cast)
+          return iter;
+        /* Move iter to the top of the linked list */
+        iter->prev->next = iter->next;
+        if (iter->next)
+          iter->next->prev = iter->prev;
+        iter->next = ty->cast;
+        iter->prev = 0;
+        if (ty->cast) ty->cast->prev = iter;
+        ty->cast = iter;
+        return iter;
+      }
+      iter = iter->next;
+    }
+  }
+  return 0;
+}
+
+/*
+  Cast a pointer up an inheritance hierarchy
+*/
+SWIGRUNTIMEINLINE void *
+SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
+}
+
+/* 
+   Dynamic pointer casting. Down an inheritance hierarchy
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty->dcast) return ty;
+  while (ty && (ty->dcast)) {
+    ty = (*ty->dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/*
+  Return the name associated with this type
+*/
+SWIGRUNTIMEINLINE const char *
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty->name;
+}
+
+/*
+  Return the pretty name associated with this type,
+  that is an unmangled type name in a form presentable to the user.
+*/
+SWIGRUNTIME const char *
+SWIG_TypePrettyName(const swig_type_info *type) {
+  /* The "str" field contains the equivalent pretty names of the
+     type, separated by vertical-bar characters.  We choose
+     to print the last name, as it is often (?) the most
+     specific. */
+  if (!type) return NULL;
+  if (type->str != NULL) {
+    const char *last_name = type->str;
+    const char *s;
+    for (s = type->str; *s; s++)
+      if (*s == '|') last_name = s+1;
+    return last_name;
+  }
+  else
+    return type->name;
+}
+
+/* 
+   Set the clientdata field for a type
+*/
+SWIGRUNTIME void
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_cast_info *cast = ti->cast;
+  /* if (ti->clientdata == clientdata) return; */
+  ti->clientdata = clientdata;
+  
+  while (cast) {
+    if (!cast->converter) {
+      swig_type_info *tc = cast->type;
+      if (!tc->clientdata) {
+	SWIG_TypeClientData(tc, clientdata);
+      }
+    }    
+    cast = cast->next;
+  }
+}
+SWIGRUNTIME void
+SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+  SWIG_TypeClientData(ti, clientdata);
+  ti->owndata = 1;
+}
+  
+/*
+  Search for a swig_type_info structure only by mangled name
+  Search is a O(log #types)
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                            swig_module_info *end, 
+		            const char *name) {
+  swig_module_info *iter = start;
+  do {
+    if (iter->size) {
+      register size_t l = 0;
+      register size_t r = iter->size - 1;
+      do {
+	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+	register size_t i = (l + r) >> 1; 
+	const char *iname = iter->types[i]->name;
+	if (iname) {
+	  register int compare = strcmp(name, iname);
+	  if (compare == 0) {	    
+	    return iter->types[i];
+	  } else if (compare < 0) {
+	    if (i) {
+	      r = i - 1;
+	    } else {
+	      break;
+	    }
+	  } else if (compare > 0) {
+	    l = i + 1;
+	  }
+	} else {
+	  break; /* should never happen */
+	}
+      } while (l <= r);
+    }
+    iter = iter->next;
+  } while (iter != end);
+  return 0;
+}
+
+/*
+  Search for a swig_type_info structure for either a mangled name or a human readable name.
+  It first searches the mangled names of the types, which is a O(log #types)
+  If a type is not found it then searches the human readable names, which is O(#types).
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeQueryModule(swig_module_info *start, 
+                     swig_module_info *end, 
+		     const char *name) {
+  /* STEP 1: Search the name field using binary search */
+  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+  if (ret) {
+    return ret;
+  } else {
+    /* STEP 2: If the type hasn't been found, do a complete search
+       of the str field (the human readable name) */
+    swig_module_info *iter = start;
+    do {
+      register size_t i = 0;
+      for (; i < iter->size; ++i) {
+	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+	  return iter->types[i];
+      }
+      iter = iter->next;
+    } while (iter != end);
+  }
+  
+  /* neither found a match */
+  return 0;
+}
+
+/* 
+   Pack binary data into a string
+*/
+SWIGRUNTIME char *
+SWIG_PackData(char *c, void *ptr, size_t sz) {
+  static const char hex[17] = "0123456789abcdef";
+  register const unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu =  u + sz;
+  for (; u != eu; ++u) {
+    register unsigned char uu = *u;
+    *(c++) = hex[(uu & 0xf0) >> 4];
+    *(c++) = hex[uu & 0xf];
+  }
+  return c;
+}
+
+/* 
+   Unpack binary data from a string
+*/
+SWIGRUNTIME const char *
+SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+  register unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu = u + sz;
+  for (; u != eu; ++u) {
+    register char d = *(c++);
+    register unsigned char uu;
+    if ((d >= '0') && (d <= '9'))
+      uu = ((d - '0') << 4);
+    else if ((d >= 'a') && (d <= 'f'))
+      uu = ((d - ('a'-10)) << 4);
+    else 
+      return (char *) 0;
+    d = *(c++);
+    if ((d >= '0') && (d <= '9'))
+      uu |= (d - '0');
+    else if ((d >= 'a') && (d <= 'f'))
+      uu |= (d - ('a'-10));
+    else 
+      return (char *) 0;
+    *u = uu;
+  }
+  return c;
+}
+
+/* 
+   Pack 'void *' into a string buffer.
+*/
+SWIGRUNTIME char *
+SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+  char *r = buff;
+  if ((2*sizeof(void *) + 2) > bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,&ptr,sizeof(void *));
+  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+  strcpy(r,name);
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,"NULL") == 0) {
+      *ptr = (void *) 0;
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sizeof(void *));
+}
+
+SWIGRUNTIME char *
+SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+  char *r = buff;
+  size_t lname = (name ? strlen(name) : 0);
+  if ((2*sz + 2 + lname) > bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  if (lname) {
+    strncpy(r,name,lname+1);
+  } else {
+    *r = 0;
+  }
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,"NULL") == 0) {
+      memset(ptr,0,sz);
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sz);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------
+ * luarun.swg
+ *
+ * This file contains the runtime support for Lua modules
+ * and includes code for managing global variables and pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lua.h"
+#include "lauxlib.h"
+#include <stdlib.h>  /* for malloc */
+#include <assert.h>  /* for a few sanity tests */
+
+/* -----------------------------------------------------------------------------
+ * global swig types
+ * ----------------------------------------------------------------------------- */
+/* Constant table */
+#define SWIG_LUA_INT     1
+#define SWIG_LUA_FLOAT   2
+#define SWIG_LUA_STRING  3
+#define SWIG_LUA_POINTER 4
+#define SWIG_LUA_BINARY  5
+#define SWIG_LUA_CHAR    6
+
+/* Structure for variable linking table */
+typedef struct {
+  const char *name;
+  lua_CFunction get;
+  lua_CFunction set;
+} swig_lua_var_info;
+
+/* Constant information structure */
+typedef struct {
+    int type;
+    char *name;
+    long lvalue;
+    double dvalue;
+    void   *pvalue;
+    swig_type_info **ptype;
+} swig_lua_const_info;
+
+typedef struct {
+  const char     *name;
+  lua_CFunction   method;
+} swig_lua_method;
+
+typedef struct {
+  const char     *name;
+  lua_CFunction   getmethod;
+  lua_CFunction   setmethod;
+} swig_lua_attribute;
+
+typedef struct swig_lua_class {
+  const char    *name;
+  swig_type_info   **type;
+  lua_CFunction  constructor;
+  void    (*destructor)(void *);
+  swig_lua_method   *methods;
+  swig_lua_attribute     *attributes;
+  struct swig_lua_class **bases;
+  const char **base_names;
+} swig_lua_class;
+
+/* this is the struct for wrappering all pointers in SwigLua
+*/
+typedef struct {
+  swig_type_info   *type;
+  int     own;  /* 1 if owned & must be destroyed */
+  void        *ptr;
+} swig_lua_userdata;
+
+/* this is the struct for wrapping arbitary packed binary data
+(currently it is only used for member function pointers)
+the data ordering is similar to swig_lua_userdata, but it is currently not possible
+to tell the two structures apart within SWIG, other than by looking at the type
+*/
+typedef struct {
+  swig_type_info   *type;
+  int     own;  /* 1 if owned & must be destroyed */
+  char data[1];       /* arbitary amount of data */    
+} swig_lua_rawdata;
+
+/* Common SWIG API */
+#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
+#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
+#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
+/* for C++ member pointers, ie, member methods */
+#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
+#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)
+
+/* Runtime API */
+#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
+#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
+#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*
+
+/* Contract support */
+#define SWIG_contract_assert(expr, msg)  \
+  if (!(expr)) { lua_pushstring(L, (char *) msg); goto fail; } else
+
+/* helper #defines */
+#define SWIG_fail {goto fail;}
+#define SWIG_fail_arg(func_name,argnum,type) \
+  {lua_pushfstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
+  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
+  goto fail;}
+#define SWIG_fail_ptr(func_name,argnum,type) \
+  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
+#define SWIG_check_num_args(func_name,a,b) \
+  if (lua_gettop(L)<a || lua_gettop(L)>b) \
+  {lua_pushfstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
+  goto fail;}
+
+
+#define SWIG_Lua_get_table(L,n) \
+  (lua_pushstring(L, n), lua_rawget(L,-2))
+
+#define SWIG_Lua_add_function(L,n,f) \
+  (lua_pushstring(L, n), \
+      lua_pushcfunction(L, f), \
+      lua_rawset(L,-3))
+
+/* special helper for allowing 'nil' for usertypes */
+#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))
+
+#ifdef __cplusplus
+/* Special helper for member function pointers 
+it gets the address, casts it, then dereferences it */
+//#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a)))
+#endif
+
+/* storing/access of swig_module_info */
+SWIGRUNTIME swig_module_info *
+SWIG_Lua_GetModule(lua_State* L) {
+  swig_module_info *ret = 0;
+  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
+  lua_rawget(L,LUA_REGISTRYINDEX);
+  if (lua_islightuserdata(L,-1))
+    ret=(swig_module_info*)lua_touserdata(L,-1);
+  lua_pop(L,1);  /* tidy */
+  return ret;
+}
+
+SWIGRUNTIME void
+SWIG_Lua_SetModule(lua_State* L, swig_module_info *module) {
+  /* add this all into the Lua registry: */
+  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
+  lua_pushlightuserdata(L,(void*)module);
+  lua_rawset(L,LUA_REGISTRYINDEX);
+}
+
+/* -----------------------------------------------------------------------------
+ * global variable support code: modules
+ * ----------------------------------------------------------------------------- */
+
+/* this function is called when trying to set an immutable.
+default value is to print an error.
+This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
+SWIGINTERN int SWIG_Lua_set_immutable(lua_State* L)
+{
+/*  there should be 1 param passed in: the new value */
+#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
+  lua_pop(L,1);  /* remove it */
+  lua_pushstring(L,"This variable is immutable");
+  lua_error(L);
+#endif
+    return 0;   /* should not return anything */
+}
+
+/* the module.get method used for getting linked data */
+SWIGINTERN int SWIG_Lua_module_get(lua_State* L)
+{
+/*  there should be 2 params passed in
+  (1) table (not the meta table)
+  (2) string name of the attribute
+  printf("SWIG_Lua_module_get %p(%s) '%s'\n",
+   lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
+   lua_tostring(L,2));
+*/
+  /* get the metatable */
+  assert(lua_istable(L,1));  /* just in case */
+  lua_getmetatable(L,1);  /* get the metatable */
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_get_table(L,".get");  /* get the .get table */
+  lua_remove(L,3);  /* remove metatable */
+  if (lua_istable(L,-1))
+  {
+    /* look for the key in the .get table */
+    lua_pushvalue(L,2);  /* key */
+    lua_rawget(L,-2);
+    lua_remove(L,3);  /* remove .get */
+    if (lua_iscfunction(L,-1))
+    {  /* found it so call the fn & return its value */
+      lua_call(L,0,1);
+      return 1;
+    }
+    lua_pop(L,1);  /* remove the top */
+  }
+  lua_pop(L,1);  /* remove the .get */
+  lua_pushnil(L);  /* return a nil */
+    return 1;
+}
+
+/* the module.set method used for setting linked data */
+SWIGINTERN int SWIG_Lua_module_set(lua_State* L)
+{
+/*  there should be 3 params passed in
+  (1) table (not the meta table)
+  (2) string name of the attribute
+  (3) any for the new value
+*/
+  /* get the metatable */
+  assert(lua_istable(L,1));  /* just in case */
+  lua_getmetatable(L,1);  /* get the metatable */
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_get_table(L,".set");  /* get the .set table */
+  lua_remove(L,4);  /* remove metatable */
+  if (lua_istable(L,-1))
+  {
+    /* look for the key in the .set table */
+    lua_pushvalue(L,2);  /* key */
+    lua_rawget(L,-2);
+    lua_remove(L,4);  /* remove .set */
+    if (lua_iscfunction(L,-1))
+    {  /* found it so call the fn & return its value */
+      lua_pushvalue(L,3);  /* value */
+      lua_call(L,1,0);
+      return 0;
+    }
+  }
+  lua_settop(L,3);  /* reset back to start */
+  /* we now have the table, key & new value, so just set directly */
+  lua_rawset(L,1);  /* add direct */
+  return 0;
+}
+
+/* registering a module in lua. Pushes the module table on the stack. */
+SWIGINTERN void  SWIG_Lua_module_begin(lua_State* L,const char* name)
+{
+  assert(lua_istable(L,-1));  /* just in case */
+  lua_pushstring(L,name);
+  lua_newtable(L);   /* the table */
+  /* add meta table */
+  lua_newtable(L);    /* the meta table */
+  SWIG_Lua_add_function(L,"__index",SWIG_Lua_module_get);
+  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_module_set);
+  lua_pushstring(L,".get");
+  lua_newtable(L);    /* the .get table */
+  lua_rawset(L,-3);  /* add .get into metatable */
+  lua_pushstring(L,".set");
+  lua_newtable(L);    /* the .set table */
+  lua_rawset(L,-3);  /* add .set into metatable */
+  lua_setmetatable(L,-2);  /* sets meta table in module */
+#ifdef SWIG_LUA_MODULE_GLOBAL
+  /* If requested, install the module directly into the global namespace. */
+  lua_rawset(L,-3);        /* add module into parent */
+  SWIG_Lua_get_table(L,name);   /* get the table back out */
+#else
+  /* Do not install the module table as global name. The stack top has
+     the module table with the name below. We pop the top and replace
+     the name with it. */
+  lua_replace(L,-2);
+#endif
+}
+
+/* ending the register */
+SWIGINTERN void  SWIG_Lua_module_end(lua_State* L)
+{
+  lua_pop(L,1);       /* tidy stack (remove module) */
+}
+
+/* adding a linked variable to the module */
+SWIGINTERN void SWIG_Lua_module_add_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
+{
+  assert(lua_istable(L,-1));  /* just in case */
+  lua_getmetatable(L,-1);  /* get the metatable */
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_get_table(L,".get"); /* find the .get table */
+  assert(lua_istable(L,-1));  /* should be a table: */
+  SWIG_Lua_add_function(L,name,getFn);
+  lua_pop(L,1);       /* tidy stack (remove table) */
+  if (setFn)  /* if there is a set fn */
+  {
+    SWIG_Lua_get_table(L,".set"); /* find the .set table */
+    assert(lua_istable(L,-1));  /* should be a table: */
+    SWIG_Lua_add_function(L,name,setFn);
+    lua_pop(L,1);       /* tidy stack (remove table) */
+  }
+  lua_pop(L,1);       /* tidy stack (remove meta) */
+}
+
+/* adding a function module */
+SWIGINTERN void  SWIG_Lua_module_add_function(lua_State* L,const char* name,lua_CFunction fn)
+{
+  SWIG_Lua_add_function(L,name,fn);
+}
+
+/* -----------------------------------------------------------------------------
+ * global variable support code: classes
+ * ----------------------------------------------------------------------------- */
+
+/* the class.get method, performs the lookup of class attributes */
+SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
+{
+/*  there should be 2 params passed in
+  (1) userdata (not the meta table)
+  (2) string name of the attribute
+*/
+  assert(lua_isuserdata(L,-2));  /* just in case */
+  lua_getmetatable(L,-2);    /* get the meta table */
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_get_table(L,".get"); /* find the .get table */
+  assert(lua_istable(L,-1));  /* just in case */
+  /* look for the key in the .get table */
+  lua_pushvalue(L,2);  /* key */
+  lua_rawget(L,-2);
+  lua_remove(L,-2); /* stack tidy, remove .get table */
+  if (lua_iscfunction(L,-1))
+  {  /* found it so call the fn & return its value */
+    lua_pushvalue(L,1);  /* the userdata */
+    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
+    lua_remove(L,-2); /* stack tidy, remove metatable */
+    return 1;
+  }
+  lua_pop(L,1);  /* remove whatever was there */
+  /* ok, so try the .fn table */
+  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
+  assert(lua_istable(L,-1));  /* just in case */
+  lua_pushvalue(L,2);  /* key */
+  lua_rawget(L,-2);  /* look for the fn */
+  lua_remove(L,-2); /* stack tidy, remove .fn table */
+  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
+  {  /* found it so return the fn & let lua call it */
+    lua_remove(L,-2); /* stack tidy, remove metatable */
+    return 1;
+  }
+  lua_pop(L,1);  /* remove whatever was there */
+  /* NEW: looks for the __getitem() fn
+  this is a user provided get fn */
+  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
+  if (lua_iscfunction(L,-1))  /* if its there */
+  {  /* found it so call the fn & return its value */
+    lua_pushvalue(L,1);  /* the userdata */
+    lua_pushvalue(L,2);  /* the parameter */
+    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
+    lua_remove(L,-2); /* stack tidy, remove metatable */
+    return 1;
+  }
+  return 0;  /* sorry not known */
+}
+
+/* the class.set method, performs the lookup of class attributes */
+SWIGINTERN int  SWIG_Lua_class_set(lua_State* L)
+{
+/*  there should be 3 params passed in
+  (1) table (not the meta table)
+  (2) string name of the attribute
+  (3) any for the new value
+printf("SWIG_Lua_class_set %p(%s) '%s' %p(%s)\n",
+      lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
+      lua_tostring(L,2),
+      lua_topointer(L,3),lua_typename(L,lua_type(L,3)));*/
+
+  assert(lua_isuserdata(L,1));  /* just in case */
+  lua_getmetatable(L,1);    /* get the meta table */
+  assert(lua_istable(L,-1));  /* just in case */
+
+  SWIG_Lua_get_table(L,".set"); /* find the .set table */
+  if (lua_istable(L,-1))
+  {
+    /* look for the key in the .set table */
+    lua_pushvalue(L,2);  /* key */
+    lua_rawget(L,-2);
+    if (lua_iscfunction(L,-1))
+    {  /* found it so call the fn & return its value */
+      lua_pushvalue(L,1);  /* userdata */
+      lua_pushvalue(L,3);  /* value */
+      lua_call(L,2,0);
+      return 0;
+    }
+    lua_pop(L,1);  /* remove the value */
+  }
+  lua_pop(L,1);  /* remove the value .set table */
+  /* NEW: looks for the __setitem() fn
+  this is a user provided set fn */
+  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
+  if (lua_iscfunction(L,-1))  /* if its there */
+  {  /* found it so call the fn & return its value */
+    lua_pushvalue(L,1);  /* the userdata */
+    lua_pushvalue(L,2);  /* the parameter */
+    lua_pushvalue(L,3);  /* the value */
+    lua_call(L,3,0);  /* 3 values in ,0 out */
+    lua_remove(L,-2); /* stack tidy, remove metatable */
+    return 1;
+  }
+  return 0;
+}
+
+/* the class.destruct method called by the interpreter */
+SWIGINTERN int  SWIG_Lua_class_destruct(lua_State* L)
+{
+/*  there should be 1 params passed in
+  (1) userdata (not the meta table) */
+  swig_lua_userdata* usr;
+  swig_lua_class* clss;
+  assert(lua_isuserdata(L,-1));  /* just in case */
+  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
+  /* if must be destroyed & has a destructor */
+  if (usr->own) /* if must be destroyed */
+  {
+    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
+    if (clss && clss->destructor)  /* there is a destroy fn */
+    {
+      clss->destructor(usr->ptr);  /* bye bye */
+    }
+  }
+  return 0;
+}
+
+/* gets the swig class registry (or creates it) */
+SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
+{
+  /* add this all into the swig registry: */
+  lua_pushstring(L,"SWIG");
+  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
+  if (!lua_istable(L,-1))  /* not there */
+  {  /* must be first time, so add it */
+    lua_pop(L,1);  /* remove the result */
+    lua_pushstring(L,"SWIG");
+    lua_newtable(L);
+    lua_rawset(L,LUA_REGISTRYINDEX);
+    /* then get it */
+    lua_pushstring(L,"SWIG");
+    lua_rawget(L,LUA_REGISTRYINDEX);
+  }
+}
+
+/* helper fn to get the classes metatable from the register */
+SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
+{
+  SWIG_Lua_get_class_registry(L);  /* get the registry */
+  lua_pushstring(L,cname);  /* get the name */
+  lua_rawget(L,-2);    /* get it */
+  lua_remove(L,-2);    /* tidy up (remove registry) */
+}
+
+/* helper add a variable to a registered class */
+SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
+{
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_get_table(L,".get"); /* find the .get table */
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_add_function(L,name,getFn);
+  lua_pop(L,1);       /* tidy stack (remove table) */
+  if (setFn)
+  {
+    SWIG_Lua_get_table(L,".set"); /* find the .set table */
+    assert(lua_istable(L,-1));  /* just in case */
+    SWIG_Lua_add_function(L,name,setFn);
+    lua_pop(L,1);       /* tidy stack (remove table) */
+  }
+}
+
+/* helper to recursively add class details (attributes & operations) */
+SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
+{
+  int i;
+  /* call all the base classes first: we can then override these later: */
+  for(i=0;clss->bases[i];i++)
+  {
+    SWIG_Lua_add_class_details(L,clss->bases[i]);
+  }
+  /* add fns */
+  for(i=0;clss->attributes[i].name;i++){
+    SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
+  }
+  /* add methods to the metatable */
+  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
+  assert(lua_istable(L,-1));  /* just in case */
+  for(i=0;clss->methods[i].name;i++){
+    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
+  }
+  lua_pop(L,1);       /* tidy stack (remove table) */
+  /*   add operator overloads
+    these look ANY method which start with "__" and assume they
+    are operator overloads & add them to the metatable
+    (this might mess up is someone defines a method __gc (the destructor)*/
+  for(i=0;clss->methods[i].name;i++){
+    if (clss->methods[i].name[0]=='_' && clss->methods[i].name[1]=='_'){
+      SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
+    }
+  }
+}
+
+/* set up the base classes pointers.
+Each class structure has a list of pointers to the base class structures.
+This function fills them.
+It cannot be done at compile time, as this will not work with hireachies
+spread over more than one swig file. 
+Therefore it must be done at runtime, querying the SWIG type system.
+*/
+SWIGINTERN void SWIG_Lua_init_base_class(lua_State* L,swig_lua_class* clss)
+{
+  int i=0;
+  swig_module_info* module=SWIG_GetModule(L);
+  for(i=0;clss->base_names[i];i++)
+  {
+    if (clss->bases[i]==0) /* not found yet */
+    {
+      /* lookup and cache the base class */
+      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
+      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
+    }
+  }	
+}
+
+/* performs the entire class registration process */
+SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
+{
+  /*  add its constructor to module with the name of the class
+  so you can do MyClass(...) as well as new_MyClass(...)
+  BUT only if a constructor is defined
+  (this overcomes the problem of pure virtual classes without constructors)*/
+  if (clss->constructor)
+    SWIG_Lua_add_function(L,clss->name,clss->constructor);
+
+  SWIG_Lua_get_class_registry(L);  /* get the registry */
+  lua_pushstring(L,clss->name);  /* get the name */
+  lua_newtable(L);    /* create the metatable */
+  /* add string of class name called ".type" */
+  lua_pushstring(L,".type");
+  lua_pushstring(L,clss->name);
+  lua_rawset(L,-3);
+  /* add a table called ".get" */
+  lua_pushstring(L,".get");
+  lua_newtable(L);
+  lua_rawset(L,-3);
+  /* add a table called ".set" */
+  lua_pushstring(L,".set");
+  lua_newtable(L);
+  lua_rawset(L,-3);
+  /* add a table called ".fn" */
+  lua_pushstring(L,".fn");
+  lua_newtable(L);
+  lua_rawset(L,-3);
+  /* add accessor fns for using the .get,.set&.fn */
+  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
+  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
+  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
+  /* add it */
+  lua_rawset(L,-3);  /* metatable into registry */
+  lua_pop(L,1);      /* tidy stack (remove registry) */
+
+  SWIG_Lua_get_class_metatable(L,clss->name);
+  SWIG_Lua_add_class_details(L,clss);  /* recursive adding of details (atts & ops) */
+  lua_pop(L,1);      /* tidy stack (remove class metatable) */
+}
+
+/* -----------------------------------------------------------------------------
+ * Class/structure conversion fns
+ * ----------------------------------------------------------------------------- */
+
+/* helper to add metatable to new lua object */
+SWIGINTERN void _SWIG_Lua_AddMetatable(lua_State* L,swig_type_info *type)
+{
+  if (type->clientdata)  /* there is clientdata: so add the metatable */
+  {
+    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->name);
+    if (lua_istable(L,-1))
+    {
+      lua_setmetatable(L,-2);
+    }
+    else
+    {
+      lua_pop(L,1);
+    }
+  }
+}
+
+/* pushes a new object into the lua stack */
+SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own)
+{
+  swig_lua_userdata* usr;
+  if (!ptr){
+    lua_pushnil(L);
+    return;
+  }
+  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
+  usr->ptr=ptr;  /* set the ptr */
+  usr->type=type;
+  usr->own=own;
+  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
+}
+
+/* takes a object from the lua stack & converts it into an object of the correct type
+ (if possible) */
+SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags)
+{
+  swig_lua_userdata* usr;
+  swig_cast_info *cast;
+  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
+  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
+  if (usr)
+  {
+    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
+    {
+        usr->own=0;
+    }
+    if (!type)            /* special cast void*, no casting fn */
+    {
+      *ptr=usr->ptr;
+      return SWIG_OK; /* ok */
+    }
+    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
+    if (cast)
+    {
+      int newmemory = 0;
+      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
+      assert(!newmemory); /* newmemory handling not yet implemented */
+      return SWIG_OK;  /* ok */
+    }
+  }
+  return SWIG_ERROR;  /* error */
+}
+
+SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State* L,int index,swig_type_info *type,int flags,
+       int argnum,const char* func_name){
+  void* result;
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
+    lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",
+      func_name,(type && type->str)?type->str:"void*",argnum);
+    lua_error(L);
+  }
+  return result;
+}
+
+/* pushes a packed userdata. user for member fn pointers only */
+SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State* L,void* ptr,size_t size,swig_type_info *type)
+{
+  swig_lua_rawdata* raw;
+  assert(ptr); /* not acceptable to pass in a NULL value */
+  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
+  raw->type=type;
+  raw->own=0;
+  memcpy(raw->data,ptr,size); /* copy the data */
+  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
+}
+    
+/* converts a packed userdata. user for member fn pointers only */
+SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State* L,int index,void* ptr,size_t size,swig_type_info *type)
+{
+  swig_lua_rawdata* raw;
+  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
+  if (!raw) return SWIG_ERROR;  /* error */
+  if (type==0 || type==raw->type) /* void* or identical type */
+  {
+    memcpy(ptr,raw->data,size); /* copy it */
+    return SWIG_OK; /* ok */
+  }
+  return SWIG_ERROR;  /* error */
+}
+
+/* a function to get the typestring of a piece of data */
+SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
+{
+  swig_lua_userdata* usr;
+  if (lua_isuserdata(L,tp))
+  {
+    usr=(swig_lua_userdata*)lua_touserdata(L,tp);  /* get data */
+    if (usr && usr->type && usr->type->str)
+      return usr->type->str;
+    return "userdata (unknown type)";
+  }
+  return lua_typename(L,lua_type(L,tp));
+}
+
+/* lua callable function to get the userdata's type */
+SWIGRUNTIME int SWIG_Lua_type(lua_State* L)
+{
+  lua_pushstring(L,SWIG_Lua_typename(L,1));
+  return 1;
+}
+
+/* lua callable function to compare userdata's value
+the issue is that two userdata may point to the same thing
+but to lua, they are different objects */
+SWIGRUNTIME int SWIG_Lua_equal(lua_State* L)
+{
+  int result;
+  swig_lua_userdata *usr1,*usr2;
+  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
+    return 0;  /* nil reply */
+  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
+  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
+  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
+  result=(usr1->ptr==usr2->ptr);
+   lua_pushboolean(L,result);
+  return 1;
+}
+
+/* -----------------------------------------------------------------------------
+ * global variable support code: class/struct typemap functions
+ * ----------------------------------------------------------------------------- */
+
+/* Install Constants */
+SWIGINTERN void
+SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]) {
+  int i;
+  for (i = 0; constants[i].type; i++) {
+    switch(constants[i].type) {
+    case SWIG_LUA_INT:
+      lua_pushstring(L,constants[i].name);
+      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
+      lua_rawset(L,-3);
+      break;
+    case SWIG_LUA_FLOAT:
+      lua_pushstring(L,constants[i].name);
+      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
+      lua_rawset(L,-3);
+      break;
+    case SWIG_LUA_CHAR:
+      lua_pushstring(L,constants[i].name);
+      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
+      lua_rawset(L,-3);
+      break;
+    case SWIG_LUA_STRING:
+      lua_pushstring(L,constants[i].name);
+      lua_pushstring(L,(char *) constants[i].pvalue);
+      lua_rawset(L,-3);
+      break;
+    case SWIG_LUA_POINTER:
+      lua_pushstring(L,constants[i].name);
+      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
+      lua_rawset(L,-3);
+      break;
+    case SWIG_LUA_BINARY:
+      lua_pushstring(L,constants[i].name);
+      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
+      lua_rawset(L,-3);
+      break;
+    default:
+      break;
+    }
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * executing lua code from within the wrapper
+ * ----------------------------------------------------------------------------- */
+
+#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
+#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
+#endif
+/* Executes a C string in Lua a really simple way of calling lua from C
+Unfortunately lua keeps changing its API's, so we need a conditional compile
+In lua 5.0.X its lua_dostring()
+In lua 5.1.X its luaL_dostring()
+*/
+SWIGINTERN int 
+SWIG_Lua_dostring(lua_State *L, const char* str) {
+  int ok,top;
+  if (str==0 || str[0]==0) return 0; /* nothing to do */
+  top=lua_gettop(L); /* save stack */
+#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
+  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
+#else
+  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
+#endif
+  if (ok!=0) {
+    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
+  }
+  lua_settop(L,top); /* restore the stack */
+  return ok;
+}    
+
+#ifdef __cplusplus
+}
+#endif
+
+/* ------------------------------ end luarun.swg  ------------------------------ */
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define SWIGTYPE_p_elsa_lsa_struct swig_types[0]
+#define SWIGTYPE_p_elsa_struct swig_types[1]
+#define SWIGTYPE_p_ospf_iface swig_types[2]
+#define SWIGTYPE_p_ospf_neighbor swig_types[3]
+#define SWIGTYPE_p_p_char swig_types[4]
+#define SWIGTYPE_p_p_unsigned_char swig_types[5]
+#define SWIGTYPE_p_proto_ospf swig_types[6]
+#define SWIGTYPE_p_size_t swig_types[7]
+#define SWIGTYPE_p_unsigned_char swig_types[8]
+#define SWIGTYPE_p_unsigned_int swig_types[9]
+#define SWIGTYPE_p_unsigned_short swig_types[10]
+#define SWIGTYPE_p_void swig_types[11]
+static swig_type_info *swig_types[13];
+static swig_module_info swig_module = {swig_types, 12, 0, 0, 0, 0};
+#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+
+/* -------- TYPES TABLE (END) -------- */
+
+#define SWIG_name      "elsac"
+#define SWIG_init      luaopen_elsac
+#define SWIG_init_user luaopen_elsac_user
+
+#define SWIG_LUACODE   luaopen_elsac_luacode
+
+
+#ifdef __cplusplus	/* generic alloc/dealloc fns*/
+#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	new TYPE[LEN]
+#define SWIG_FREE_ARRAY(PTR)		delete[] PTR
+#else
+#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	(TYPE *)malloc(LEN*sizeof(TYPE))
+#define SWIG_FREE_ARRAY(PTR)		free(PTR)
+#endif
+/* counting the size of arrays:*/
+SWIGINTERN int SWIG_itable_size(lua_State* L, int index)
+{
+	int n=0;
+	while(1){
+		lua_rawgeti(L,index,n+1);
+		if (lua_isnil(L,-1))break;
+		++n;
+		lua_pop(L,1);
+	}
+	lua_pop(L,1);
+	return n;
+}
+
+SWIGINTERN int SWIG_table_size(lua_State* L, int index)
+{
+	int n=0;
+	lua_pushnil(L);  /* first key*/
+	while (lua_next(L, index) != 0) {
+		++n;
+		lua_pop(L, 1);  /* removes `value'; keeps `key' for next iteration*/
+	}
+	return n;
+}
+
+/* super macro to declare array typemap helper fns */
+#define SWIG_DECLARE_TYPEMAP_ARR_FN(NAME,TYPE)\
+	SWIGINTERN int SWIG_read_##NAME##_num_array(lua_State* L,int index,TYPE *array,int size){\
+		int i;\
+		for (i = 0; i < size; i++) {\
+			lua_rawgeti(L,index,i+1);\
+			if (lua_isnumber(L,-1)){\
+				array[i] = (TYPE)lua_tonumber(L,-1);\
+			} else {\
+				lua_pop(L,1);\
+				return 0;\
+			}\
+			lua_pop(L,1);\
+		}\
+		return 1;\
+	}\
+	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_fixed(lua_State* L, int index, int size){\
+		TYPE *array;\
+		if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {\
+			lua_pushfstring(L,"expected a table of size %d",size);\
+			return 0;\
+		}\
+		array=SWIG_ALLOC_ARRAY(TYPE,size);\
+		if (!SWIG_read_##NAME##_num_array(L,index,array,size)){\
+			lua_pushstring(L,"table must contain numbers");\
+			SWIG_FREE_ARRAY(array);\
+			return 0;\
+		}\
+		return array;\
+	}\
+	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_var(lua_State* L, int index, int* size)\
+	{\
+		TYPE *array;\
+		if (!lua_istable(L,index)) {\
+			lua_pushstring(L,"expected a table");\
+			return 0;\
+		}\
+		*size=SWIG_itable_size(L,index);\
+		if (*size<1){\
+			lua_pushstring(L,"table appears to be empty");\
+			return 0;\
+		}\
+		array=SWIG_ALLOC_ARRAY(TYPE,*size);\
+		if (!SWIG_read_##NAME##_num_array(L,index,array,*size)){\
+			lua_pushstring(L,"table must contain numbers");\
+			SWIG_FREE_ARRAY(array);\
+			return 0;\
+		}\
+		return array;\
+	}\
+	SWIGINTERN void SWIG_write_##NAME##_num_array(lua_State* L,TYPE *array,int size){\
+		int i;\
+		lua_newtable(L);\
+		for (i = 0; i < size; i++){\
+			lua_pushnumber(L,(lua_Number)array[i]);\
+			lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/ \
+		}\
+	}
+
+SWIG_DECLARE_TYPEMAP_ARR_FN(schar,signed char);
+SWIG_DECLARE_TYPEMAP_ARR_FN(uchar,unsigned char);
+SWIG_DECLARE_TYPEMAP_ARR_FN(int,int);
+SWIG_DECLARE_TYPEMAP_ARR_FN(uint,unsigned int);
+SWIG_DECLARE_TYPEMAP_ARR_FN(short,short);
+SWIG_DECLARE_TYPEMAP_ARR_FN(ushort,unsigned short);
+SWIG_DECLARE_TYPEMAP_ARR_FN(long,long);
+SWIG_DECLARE_TYPEMAP_ARR_FN(ulong,unsigned long);
+SWIG_DECLARE_TYPEMAP_ARR_FN(float,float);
+SWIG_DECLARE_TYPEMAP_ARR_FN(double,double);
+
+SWIGINTERN int SWIG_read_ptr_array(lua_State* L,int index,void **array,int size,swig_type_info *type){
+	int i;
+	for (i = 0; i < size; i++) {
+		lua_rawgeti(L,index,i+1);
+		if (!lua_isuserdata(L,-1) || SWIG_ConvertPtr(L,-1,&array[i],type,0)==-1){
+			lua_pop(L,1);
+			return 0;
+		}
+		lua_pop(L,1);
+	}
+	return 1;
+}
+SWIGINTERN void** SWIG_get_ptr_array_fixed(lua_State* L, int index, int size,swig_type_info *type){
+	void **array;
+	if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {
+		lua_pushfstring(L,"expected a table of size %d",size);
+		return 0;
+	}
+	array=SWIG_ALLOC_ARRAY(void*,size);
+	if (!SWIG_read_ptr_array(L,index,array,size,type)){
+		lua_pushfstring(L,"table must contain pointers of type %s",type->name);
+		SWIG_FREE_ARRAY(array);
+		return 0;
+	}
+	return array;
+}
+SWIGINTERN void** SWIG_get_ptr_array_var(lua_State* L, int index, int* size,swig_type_info *type){
+	void **array;
+	if (!lua_istable(L,index)) {
+		lua_pushstring(L,"expected a table");
+		return 0;
+	}
+	*size=SWIG_itable_size(L,index);
+	if (*size<1){
+		lua_pushstring(L,"table appears to be empty");
+		return 0;
+	}
+	array=SWIG_ALLOC_ARRAY(void*,*size);
+	if (!SWIG_read_ptr_array(L,index,array,*size,type)){
+		lua_pushfstring(L,"table must contain pointers of type %s",type->name);
+		SWIG_FREE_ARRAY(array);
+		return 0;
+	}
+	return array;
+}
+SWIGINTERN void SWIG_write_ptr_array(lua_State* L,void **array,int size,swig_type_info *type,int own){
+	int i;
+	lua_newtable(L);
+	for (i = 0; i < size; i++){
+		SWIG_NewPointerObj(L,array[i],type,own);
+		lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/
+	}
+}
+
+
+#include "elsa.h"
+#include "elsa_internal.h"
+
+
+SWIGINTERN int SWIG_lua_isnilstring(lua_State *L, int idx) {
+  int ret = lua_isstring(L, idx);
+  if (!ret)
+   ret = lua_isnil(L, idx);
+  return ret;
+}
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+static int _wrap_elsa_struct_client_set(lua_State* L) {
+  int SWIG_arg = 0;
+  struct elsa_struct *arg1 = (struct elsa_struct *) 0 ;
+  elsa_client arg2 = (elsa_client) 0 ;
+  
+  SWIG_check_num_args("elsa_struct::client",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_struct::client",1,"struct elsa_struct *");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsa_struct::client",2,"elsa_client");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_struct_client_set",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_proto_ospf,SWIG_POINTER_DISOWN))){
+    SWIG_fail_ptr("elsa_struct_client_set",2,SWIGTYPE_p_proto_ospf);
+  }
+  
+  if (arg1) (arg1)->client = arg2;
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_struct_client_get(lua_State* L) {
+  int SWIG_arg = 0;
+  struct elsa_struct *arg1 = (struct elsa_struct *) 0 ;
+  elsa_client result;
+  
+  SWIG_check_num_args("elsa_struct::client",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_struct::client",1,"struct elsa_struct *");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_struct_client_get",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  result = (elsa_client) ((arg1)->client);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_proto_ospf,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_new_elsa_struct(lua_State* L) {
+  int SWIG_arg = 0;
+  struct elsa_struct *result = 0 ;
+  
+  SWIG_check_num_args("elsa_struct::elsa_struct",0,0)
+  result = (struct elsa_struct *)calloc(1, sizeof(struct elsa_struct));
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_elsa_struct,1); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static void swig_delete_elsa_struct(void *obj) {
+struct elsa_struct *arg1 = (struct elsa_struct *) obj;
+free((char *) arg1);
+}
+static swig_lua_method swig_elsa_struct_methods[] = {
+    {0,0}
+};
+static swig_lua_attribute swig_elsa_struct_attributes[] = {
+    { "client", _wrap_elsa_struct_client_get, _wrap_elsa_struct_client_set},
+    {0,0,0}
+};
+static swig_lua_class *swig_elsa_struct_bases[] = {0};
+static const char *swig_elsa_struct_base_names[] = {0};
+static swig_lua_class _wrap_class_elsa_struct = { "elsa_struct", &SWIGTYPE_p_elsa_struct,_wrap_new_elsa_struct, swig_delete_elsa_struct, swig_elsa_struct_methods, swig_elsa_struct_attributes, swig_elsa_struct_bases, swig_elsa_struct_base_names };
+
+static int _wrap_elsa_create(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa result;
+  
+  SWIG_check_num_args("elsa_create",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_create",1,"elsa_client");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsa_create",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  result = (elsa)elsa_create(arg1);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_elsa_struct,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_notify_changed_lsa(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa arg1 = (elsa) 0 ;
+  elsa_lsa arg2 = (elsa_lsa) 0 ;
+  
+  SWIG_check_num_args("elsa_notify_changed_lsa",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_notify_changed_lsa",1,"elsa");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsa_notify_changed_lsa",2,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_notify_changed_lsa",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsa_notify_changed_lsa",2,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  elsa_notify_changed_lsa(arg1,arg2);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_notify_deleting_lsa(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa arg1 = (elsa) 0 ;
+  elsa_lsa arg2 = (elsa_lsa) 0 ;
+  
+  SWIG_check_num_args("elsa_notify_deleting_lsa",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_notify_deleting_lsa",1,"elsa");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsa_notify_deleting_lsa",2,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_notify_deleting_lsa",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsa_notify_deleting_lsa",2,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  elsa_notify_deleting_lsa(arg1,arg2);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_notify_duplicate_lsa(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa arg1 = (elsa) 0 ;
+  elsa_lsa arg2 = (elsa_lsa) 0 ;
+  
+  SWIG_check_num_args("elsa_notify_duplicate_lsa",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_notify_duplicate_lsa",1,"elsa");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsa_notify_duplicate_lsa",2,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_notify_duplicate_lsa",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsa_notify_duplicate_lsa",2,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  elsa_notify_duplicate_lsa(arg1,arg2);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_dispatch(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa arg1 = (elsa) 0 ;
+  
+  SWIG_check_num_args("elsa_dispatch",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_dispatch",1,"elsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_dispatch",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  elsa_dispatch(arg1);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_destroy(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa arg1 = (elsa) 0 ;
+  
+  SWIG_check_num_args("elsa_destroy",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsa_destroy",1,"elsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_struct,0))){
+    SWIG_fail_ptr("elsa_destroy",1,SWIGTYPE_p_elsa_struct);
+  }
+  
+  elsa_destroy(arg1);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_calloc(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  size_t arg2 ;
+  void *result = 0 ;
+  
+  SWIG_check_num_args("elsai_calloc",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_calloc",1,"elsa_client");
+  if(!lua_isnumber(L,2)) SWIG_fail_arg("elsai_calloc",2,"size_t");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_calloc",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
+  arg2 = (size_t)lua_tonumber(L, 2);
+  result = (void *)elsai_calloc(arg1,arg2);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_free(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  void *arg2 = (void *) 0 ;
+  
+  SWIG_check_num_args("elsai_free",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_free",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_free",2,"void *");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_free",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"elsai_free");
+  elsai_free(arg1,arg2);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_get_rid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  uint32_t result;
+  
+  SWIG_check_num_args("elsai_get_rid",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_get_rid",1,"elsa_client");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_get_rid",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  result = (uint32_t)elsai_get_rid(arg1);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_change_rid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  
+  SWIG_check_num_args("elsai_change_rid",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_change_rid",1,"elsa_client");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_change_rid",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  elsai_change_rid(arg1);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_route_to_rid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  uint32_t arg2 ;
+  char **arg3 = (char **) 0 ;
+  char **arg4 = (char **) 0 ;
+  char *nh3 ;
+  char *ifname3 ;
+  
+  {
+    arg3 = &nh3;
+    arg4 = &ifname3;
+  }
+  SWIG_check_num_args("elsai_route_to_rid",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_route_to_rid",1,"elsa_client");
+  if(!lua_isnumber(L,2)) SWIG_fail_arg("elsai_route_to_rid",2,"uint32_t");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_route_to_rid",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
+  arg2 = (uint32_t)lua_tonumber(L, 2);
+  elsai_route_to_rid(arg1,arg2,arg3,arg4);
+  
+  {
+    if (*arg3 && *arg4)
+    {
+      lua_pushlstring(L, *arg3, strlen(*arg3)); SWIG_arg++;
+      lua_pushlstring(L, *arg4, strlen(*arg4)); SWIG_arg++;
+    }
+  }
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_lsa_originate(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_lsatype arg2 ;
+  uint32_t arg3 ;
+  uint32_t arg4 ;
+  unsigned char *arg5 = (unsigned char *) 0 ;
+  size_t arg6 ;
+  
+  SWIG_check_num_args("elsai_lsa_originate",5,5)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_lsa_originate",1,"elsa_client");
+  if(!lua_isnumber(L,2)) SWIG_fail_arg("elsai_lsa_originate",2,"elsa_lsatype");
+  if(!lua_isnumber(L,3)) SWIG_fail_arg("elsai_lsa_originate",3,"uint32_t");
+  if(!lua_isnumber(L,4)) SWIG_fail_arg("elsai_lsa_originate",4,"uint32_t");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_lsa_originate",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
+  arg2 = (elsa_lsatype)lua_tonumber(L, 2);
+  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
+  arg3 = (uint32_t)lua_tonumber(L, 3);
+  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
+  arg4 = (uint32_t)lua_tonumber(L, 4);
+  {
+    if(!lua_isstring(L,5)) SWIG_fail_arg("???",5,"<lua string>");
+    arg5 = (unsigned char *)lua_tolstring(L, 5, &arg6);
+  }
+  elsai_lsa_originate(arg1,arg2,arg3,arg4,(unsigned char const *)arg5,arg6);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_get_lsa_by_type(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_lsatype arg2 ;
+  elsa_lsa result;
+  
+  SWIG_check_num_args("elsai_get_lsa_by_type",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_get_lsa_by_type",1,"elsa_client");
+  if(!lua_isnumber(L,2)) SWIG_fail_arg("elsai_get_lsa_by_type",2,"elsa_lsatype");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_get_lsa_by_type",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
+  arg2 = (elsa_lsatype)lua_tonumber(L, 2);
+  result = (elsa_lsa)elsai_get_lsa_by_type(arg1,arg2);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_elsa_lsa_struct,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_get_lsa_by_type_next(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_lsa arg2 = (elsa_lsa) 0 ;
+  elsa_lsa result;
+  
+  SWIG_check_num_args("elsai_get_lsa_by_type_next",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_get_lsa_by_type_next",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_get_lsa_by_type_next",2,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_get_lsa_by_type_next",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsai_get_lsa_by_type_next",2,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  result = (elsa_lsa)elsai_get_lsa_by_type_next(arg1,arg2);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_elsa_lsa_struct,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_lsa_get_type(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_lsa arg1 = (elsa_lsa) 0 ;
+  elsa_lsatype result;
+  
+  SWIG_check_num_args("elsai_lsa_get_type",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_lsa_get_type",1,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsai_lsa_get_type",1,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  result = (elsa_lsatype)elsai_lsa_get_type(arg1);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_lsa_get_rid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_lsa arg1 = (elsa_lsa) 0 ;
+  uint32_t result;
+  
+  SWIG_check_num_args("elsai_lsa_get_rid",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_lsa_get_rid",1,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsai_lsa_get_rid",1,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  result = (uint32_t)elsai_lsa_get_rid(arg1);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_lsa_get_lsid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_lsa arg1 = (elsa_lsa) 0 ;
+  uint32_t result;
+  
+  SWIG_check_num_args("elsai_lsa_get_lsid",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_lsa_get_lsid",1,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsai_lsa_get_lsid",1,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  result = (uint32_t)elsai_lsa_get_lsid(arg1);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_lsa_get_body(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_lsa arg1 = (elsa_lsa) 0 ;
+  unsigned char **arg2 = (unsigned char **) 0 ;
+  size_t *arg3 = (size_t *) 0 ;
+  unsigned char *b2 ;
+  size_t bs2 ;
+  
+  {
+    arg2 = &b2;
+    arg3 = &bs2;
+  }
+  SWIG_check_num_args("elsai_lsa_get_body",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_lsa_get_body",1,"elsa_lsa");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_elsa_lsa_struct,0))){
+    SWIG_fail_ptr("elsai_lsa_get_body",1,SWIGTYPE_p_elsa_lsa_struct);
+  }
+  
+  elsai_lsa_get_body(arg1,arg2,arg3);
+  
+  {
+    lua_pushlstring(L, *arg2, *arg3); SWIG_arg++;
+  }
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_if_get(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_if result;
+  
+  SWIG_check_num_args("elsai_if_get",1,1)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_if_get",1,"elsa_client");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_if_get",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  result = (elsa_if)elsai_if_get(arg1);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ospf_iface,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_if_get_next(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_if arg2 = (elsa_if) 0 ;
+  elsa_if result;
+  
+  SWIG_check_num_args("elsai_if_get_next",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_if_get_next",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_if_get_next",2,"elsa_if");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_if_get_next",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_iface,0))){
+    SWIG_fail_ptr("elsai_if_get_next",2,SWIGTYPE_p_ospf_iface);
+  }
+  
+  result = (elsa_if)elsai_if_get_next(arg1,arg2);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ospf_iface,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_if_get_name(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_if arg2 = (elsa_if) 0 ;
+  char *result = 0 ;
+  
+  SWIG_check_num_args("elsai_if_get_name",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_if_get_name",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_if_get_name",2,"elsa_if");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_if_get_name",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_iface,0))){
+    SWIG_fail_ptr("elsai_if_get_name",2,SWIGTYPE_p_ospf_iface);
+  }
+  
+  result = (char *)elsai_if_get_name(arg1,arg2);
+  lua_pushstring(L,(const char *)result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_if_get_index(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_if arg2 = (elsa_if) 0 ;
+  uint32_t result;
+  
+  SWIG_check_num_args("elsai_if_get_index",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_if_get_index",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_if_get_index",2,"elsa_if");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_if_get_index",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_iface,0))){
+    SWIG_fail_ptr("elsai_if_get_index",2,SWIGTYPE_p_ospf_iface);
+  }
+  
+  result = (uint32_t)elsai_if_get_index(arg1,arg2);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_if_get_priority(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_if arg2 = (elsa_if) 0 ;
+  uint8_t result;
+  
+  SWIG_check_num_args("elsai_if_get_priority",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_if_get_priority",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_if_get_priority",2,"elsa_if");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_if_get_priority",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_iface,0))){
+    SWIG_fail_ptr("elsai_if_get_priority",2,SWIGTYPE_p_ospf_iface);
+  }
+  
+  result = (uint8_t)elsai_if_get_priority(arg1,arg2);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_if_get_neigh(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_if arg2 = (elsa_if) 0 ;
+  elsa_neigh result;
+  
+  SWIG_check_num_args("elsai_if_get_neigh",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_if_get_neigh",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_if_get_neigh",2,"elsa_if");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_if_get_neigh",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_iface,0))){
+    SWIG_fail_ptr("elsai_if_get_neigh",2,SWIGTYPE_p_ospf_iface);
+  }
+  
+  result = (elsa_neigh)elsai_if_get_neigh(arg1,arg2);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ospf_neighbor,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_neigh_get_rid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_neigh arg2 = (elsa_neigh) 0 ;
+  uint32_t result;
+  
+  SWIG_check_num_args("elsai_neigh_get_rid",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_neigh_get_rid",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_neigh_get_rid",2,"elsa_neigh");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_neigh_get_rid",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_neighbor,0))){
+    SWIG_fail_ptr("elsai_neigh_get_rid",2,SWIGTYPE_p_ospf_neighbor);
+  }
+  
+  result = (uint32_t)elsai_neigh_get_rid(arg1,arg2);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_neigh_get_iid(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_neigh arg2 = (elsa_neigh) 0 ;
+  uint32_t result;
+  
+  SWIG_check_num_args("elsai_neigh_get_iid",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_neigh_get_iid",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_neigh_get_iid",2,"elsa_neigh");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_neigh_get_iid",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_neighbor,0))){
+    SWIG_fail_ptr("elsai_neigh_get_iid",2,SWIGTYPE_p_ospf_neighbor);
+  }
+  
+  result = (uint32_t)elsai_neigh_get_iid(arg1,arg2);
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_neigh_get_next(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_client arg1 = (elsa_client) 0 ;
+  elsa_neigh arg2 = (elsa_neigh) 0 ;
+  elsa_neigh result;
+  
+  SWIG_check_num_args("elsai_neigh_get_next",2,2)
+  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("elsai_neigh_get_next",1,"elsa_client");
+  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("elsai_neigh_get_next",2,"elsa_neigh");
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_proto_ospf,0))){
+    SWIG_fail_ptr("elsai_neigh_get_next",1,SWIGTYPE_p_proto_ospf);
+  }
+  
+  
+  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ospf_neighbor,0))){
+    SWIG_fail_ptr("elsai_neigh_get_next",2,SWIGTYPE_p_ospf_neighbor);
+  }
+  
+  result = (elsa_neigh)elsai_neigh_get_next(arg1,arg2);
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ospf_neighbor,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsai_get_log_level(lua_State* L) {
+  int SWIG_arg = 0;
+  int result;
+  
+  SWIG_check_num_args("elsai_get_log_level",0,0)
+  result = (int)elsai_get_log_level();
+  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_active_get(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa result;
+  
+  SWIG_check_num_args("elsa_active_get",0,0)
+  result = (elsa)elsa_active_get();
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_elsa_struct,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_active_lsa_get(lua_State* L) {
+  int SWIG_arg = 0;
+  elsa_lsa result;
+  
+  SWIG_check_num_args("elsa_active_lsa_get",0,0)
+  result = (elsa_lsa)elsa_active_lsa_get();
+  SWIG_NewPointerObj(L,result,SWIGTYPE_p_elsa_lsa_struct,0); SWIG_arg++; 
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+static int _wrap_elsa_log_string(lua_State* L) {
+  int SWIG_arg = 0;
+  char *arg1 = (char *) 0 ;
+  
+  SWIG_check_num_args("elsa_log_string",1,1)
+  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("elsa_log_string",1,"char const *");
+  arg1 = (char *)lua_tostring(L, 1);
+  elsa_log_string((char const *)arg1);
+  
+  return SWIG_arg;
+  
+  if(0) SWIG_fail;
+  
+fail:
+  lua_error(L);
+  return SWIG_arg;
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
+static const struct luaL_reg swig_commands[] = {
+    { "elsa_create", _wrap_elsa_create},
+    { "elsa_notify_changed_lsa", _wrap_elsa_notify_changed_lsa},
+    { "elsa_notify_deleting_lsa", _wrap_elsa_notify_deleting_lsa},
+    { "elsa_notify_duplicate_lsa", _wrap_elsa_notify_duplicate_lsa},
+    { "elsa_dispatch", _wrap_elsa_dispatch},
+    { "elsa_destroy", _wrap_elsa_destroy},
+    { "elsai_calloc", _wrap_elsai_calloc},
+    { "elsai_free", _wrap_elsai_free},
+    { "elsai_get_rid", _wrap_elsai_get_rid},
+    { "elsai_change_rid", _wrap_elsai_change_rid},
+    { "elsai_route_to_rid", _wrap_elsai_route_to_rid},
+    { "elsai_lsa_originate", _wrap_elsai_lsa_originate},
+    { "elsai_get_lsa_by_type", _wrap_elsai_get_lsa_by_type},
+    { "elsai_get_lsa_by_type_next", _wrap_elsai_get_lsa_by_type_next},
+    { "elsai_lsa_get_type", _wrap_elsai_lsa_get_type},
+    { "elsai_lsa_get_rid", _wrap_elsai_lsa_get_rid},
+    { "elsai_lsa_get_lsid", _wrap_elsai_lsa_get_lsid},
+    { "elsai_lsa_get_body", _wrap_elsai_lsa_get_body},
+    { "elsai_if_get", _wrap_elsai_if_get},
+    { "elsai_if_get_next", _wrap_elsai_if_get_next},
+    { "elsai_if_get_name", _wrap_elsai_if_get_name},
+    { "elsai_if_get_index", _wrap_elsai_if_get_index},
+    { "elsai_if_get_priority", _wrap_elsai_if_get_priority},
+    { "elsai_if_get_neigh", _wrap_elsai_if_get_neigh},
+    { "elsai_neigh_get_rid", _wrap_elsai_neigh_get_rid},
+    { "elsai_neigh_get_iid", _wrap_elsai_neigh_get_iid},
+    { "elsai_neigh_get_next", _wrap_elsai_neigh_get_next},
+    { "elsai_get_log_level", _wrap_elsai_get_log_level},
+    { "elsa_active_get", _wrap_elsa_active_get},
+    { "elsa_active_lsa_get", _wrap_elsa_active_lsa_get},
+    { "elsa_log_string", _wrap_elsa_log_string},
+    {0,0}
+};
+
+static swig_lua_var_info swig_variables[] = {
+    {0,0,0}
+};
+
+static swig_lua_const_info swig_constants[] = {
+{ SWIG_LUA_INT,     (char *)"LSA_T_RT", (long) 0x2001, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_NET", (long) 0x2002, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_SUM_NET", (long) 0x2003, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_SUM_RT", (long) 0x2004, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_EXT", (long) 0x4005, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_NSSA", (long) 0x2007, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_LINK", (long) 0x0008, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"LSA_T_PREFIX", (long) 0x2009, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"ELSA_DEBUG_LEVEL_ERROR", (long) 1, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"ELSA_DEBUG_LEVEL_INFO", (long) 2, 0, 0, 0},
+{ SWIG_LUA_INT,     (char *)"ELSA_DEBUG_LEVEL_DEBUG", (long) 3, 0, 0, 0},
+    {0,0,0,0,0,0}
+};
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static swig_type_info _swigt__p_elsa_lsa_struct = {"_p_elsa_lsa_struct", "elsa_lsa|struct elsa_lsa_struct *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_elsa_struct = {"_p_elsa_struct", "struct elsa_struct *|elsa_struct *|elsa", 0, 0, (void*)&_wrap_class_elsa_struct, 0};
+static swig_type_info _swigt__p_ospf_iface = {"_p_ospf_iface", "struct ospf_iface *|elsa_if", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_ospf_neighbor = {"_p_ospf_neighbor", "struct ospf_neighbor *|elsa_neigh", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_unsigned_char = {"_p_p_unsigned_char", "unsigned char **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_proto_ospf = {"_p_proto_ospf", "struct proto_ospf *|elsa_client", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|uint8_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|unsigned int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "elsa_lsatype *|unsigned short *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};
+
+static swig_type_info *swig_type_initial[] = {
+  &_swigt__p_elsa_lsa_struct,
+  &_swigt__p_elsa_struct,
+  &_swigt__p_ospf_iface,
+  &_swigt__p_ospf_neighbor,
+  &_swigt__p_p_char,
+  &_swigt__p_p_unsigned_char,
+  &_swigt__p_proto_ospf,
+  &_swigt__p_size_t,
+  &_swigt__p_unsigned_char,
+  &_swigt__p_unsigned_int,
+  &_swigt__p_unsigned_short,
+  &_swigt__p_void,
+};
+
+static swig_cast_info _swigc__p_elsa_lsa_struct[] = {  {&_swigt__p_elsa_lsa_struct, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_elsa_struct[] = {  {&_swigt__p_elsa_struct, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_ospf_iface[] = {  {&_swigt__p_ospf_iface, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_ospf_neighbor[] = {  {&_swigt__p_ospf_neighbor, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_unsigned_char[] = {  {&_swigt__p_p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_proto_ospf[] = {  {&_swigt__p_proto_ospf, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
+
+static swig_cast_info *swig_cast_initial[] = {
+  _swigc__p_elsa_lsa_struct,
+  _swigc__p_elsa_struct,
+  _swigc__p_ospf_iface,
+  _swigc__p_ospf_neighbor,
+  _swigc__p_p_char,
+  _swigc__p_p_unsigned_char,
+  _swigc__p_proto_ospf,
+  _swigc__p_size_t,
+  _swigc__p_unsigned_char,
+  _swigc__p_unsigned_int,
+  _swigc__p_unsigned_short,
+  _swigc__p_void,
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+/* -----------------------------------------------------------------------------
+ * Type initialization:
+ * This problem is tough by the requirement that no dynamic 
+ * memory is used. Also, since swig_type_info structures store pointers to 
+ * swig_cast_info structures and swig_cast_info structures store pointers back
+ * to swig_type_info structures, we need some lookup code at initialization. 
+ * The idea is that swig generates all the structures that are needed. 
+ * The runtime then collects these partially filled structures. 
+ * The SWIG_InitializeModule function takes these initial arrays out of 
+ * swig_module, and does all the lookup, filling in the swig_module.types
+ * array with the correct data and linking the correct swig_cast_info
+ * structures together.
+ *
+ * The generated swig_type_info structures are assigned staticly to an initial 
+ * array. We just loop through that array, and handle each type individually.
+ * First we lookup if this type has been already loaded, and if so, use the
+ * loaded structure instead of the generated one. Then we have to fill in the
+ * cast linked list. The cast data is initially stored in something like a
+ * two-dimensional array. Each row corresponds to a type (there are the same
+ * number of rows as there are in the swig_type_initial array). Each entry in
+ * a column is one of the swig_cast_info structures for that type.
+ * The cast_initial array is actually an array of arrays, because each row has
+ * a variable number of columns. So to actually build the cast linked list,
+ * we find the array of casts associated with the type, and loop through it 
+ * adding the casts to the list. The one last trick we need to do is making
+ * sure the type pointer in the swig_cast_info struct is correct.
+ *
+ * First off, we lookup the cast->type name to see if it is already loaded. 
+ * There are three cases to handle:
+ *  1) If the cast->type has already been loaded AND the type we are adding
+ *     casting info to has not been loaded (it is in this module), THEN we
+ *     replace the cast->type pointer with the type pointer that has already
+ *     been loaded.
+ *  2) If BOTH types (the one we are adding casting info to, and the 
+ *     cast->type) are loaded, THEN the cast info has already been loaded by
+ *     the previous module so we just ignore it.
+ *  3) Finally, if cast->type has not already been loaded, then we add that
+ *     swig_cast_info to the linked list (because the cast->type) pointer will
+ *     be correct.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#if 0
+} /* c-mode */
+#endif
+#endif
+
+#if 0
+#define SWIGRUNTIME_DEBUG
+#endif
+
+
+SWIGRUNTIME void
+SWIG_InitializeModule(void *clientdata) {
+  size_t i;
+  swig_module_info *module_head, *iter;
+  int found, init;
+
+  clientdata = clientdata;
+
+  /* check to see if the circular list has been setup, if not, set it up */
+  if (swig_module.next==0) {
+    /* Initialize the swig_module */
+    swig_module.type_initial = swig_type_initial;
+    swig_module.cast_initial = swig_cast_initial;
+    swig_module.next = &swig_module;
+    init = 1;
+  } else {
+    init = 0;
+  }
+
+  /* Try and load any already created modules */
+  module_head = SWIG_GetModule(clientdata);
+  if (!module_head) {
+    /* This is the first module loaded for this interpreter */
+    /* so set the swig module into the interpreter */
+    SWIG_SetModule(clientdata, &swig_module);
+    module_head = &swig_module;
+  } else {
+    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+    found=0;
+    iter=module_head;
+    do {
+      if (iter==&swig_module) {
+        found=1;
+        break;
+      }
+      iter=iter->next;
+    } while (iter!= module_head);
+
+    /* if the is found in the list, then all is done and we may leave */
+    if (found) return;
+    /* otherwise we must add out module into the list */
+    swig_module.next = module_head->next;
+    module_head->next = &swig_module;
+  }
+
+  /* When multiple interpeters are used, a module could have already been initialized in
+     a different interpreter, but not yet have a pointer in this interpreter.
+     In this case, we do not want to continue adding types... everything should be
+     set up already */
+  if (init == 0) return;
+
+  /* Now work on filling in swig_module.types */
+#ifdef SWIGRUNTIME_DEBUG
+  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+#endif
+  for (i = 0; i < swig_module.size; ++i) {
+    swig_type_info *type = 0;
+    swig_type_info *ret;
+    swig_cast_info *cast;
+  
+#ifdef SWIGRUNTIME_DEBUG
+    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+#endif
+
+    /* if there is another module already loaded */
+    if (swig_module.next != &swig_module) {
+      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+    }
+    if (type) {
+      /* Overwrite clientdata field */
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: found type %s\n", type->name);
+#endif
+      if (swig_module.type_initial[i]->clientdata) {
+	type->clientdata = swig_module.type_initial[i]->clientdata;
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+#endif
+      }
+    } else {
+      type = swig_module.type_initial[i];
+    }
+
+    /* Insert casting types */
+    cast = swig_module.cast_initial[i];
+    while (cast->type) {
+    
+      /* Don't need to add information already in the list */
+      ret = 0;
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+#endif
+      if (swig_module.next != &swig_module) {
+        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+#ifdef SWIGRUNTIME_DEBUG
+	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+#endif
+      }
+      if (ret) {
+	if (type == swig_module.type_initial[i]) {
+#ifdef SWIGRUNTIME_DEBUG
+	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+#endif
+	  cast->type = ret;
+	  ret = 0;
+	} else {
+	  /* Check for casting already in the list */
+	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+#ifdef SWIGRUNTIME_DEBUG
+	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+#endif
+	  if (!ocast) ret = 0;
+	}
+      }
+
+      if (!ret) {
+#ifdef SWIGRUNTIME_DEBUG
+	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+#endif
+        if (type->cast) {
+          type->cast->prev = cast;
+          cast->next = type->cast;
+        }
+        type->cast = cast;
+      }
+      cast++;
+    }
+    /* Set entry in modules->types array equal to the type */
+    swig_module.types[i] = type;
+  }
+  swig_module.types[i] = 0;
+
+#ifdef SWIGRUNTIME_DEBUG
+  printf("**** SWIG_InitializeModule: Cast List ******\n");
+  for (i = 0; i < swig_module.size; ++i) {
+    int j = 0;
+    swig_cast_info *cast = swig_module.cast_initial[i];
+    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+    while (cast->type) {
+      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+      cast++;
+      ++j;
+    }
+  printf("---- Total casts: %d\n",j);
+  }
+  printf("**** SWIG_InitializeModule: Cast List ******\n");
+#endif
+}
+
+/* This function will propagate the clientdata field of type to
+* any new swig_type_info structures that have been added into the list
+* of equivalent types.  It is like calling
+* SWIG_TypeClientData(type, clientdata) a second time.
+*/
+SWIGRUNTIME void
+SWIG_PropagateClientData(void) {
+  size_t i;
+  swig_cast_info *equiv;
+  static int init_run = 0;
+
+  if (init_run) return;
+  init_run = 1;
+
+  for (i = 0; i < swig_module.size; i++) {
+    if (swig_module.types[i]->clientdata) {
+      equiv = swig_module.types[i]->cast;
+      while (equiv) {
+        if (!equiv->converter) {
+          if (equiv->type && !equiv->type->clientdata)
+            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+        }
+        equiv = equiv->next;
+      }
+    }
+  }
+}
+
+#ifdef __cplusplus
+#if 0
+{ /* c-mode */
+#endif
+}
+#endif
+
+
+
+/* Forward declaration of where the user's %init{} gets inserted */
+void SWIG_init_user(lua_State* L );
+    
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* this is the initialization function
+  added at the very end of the code
+  the function is always called SWIG_init, but an eariler #define will rename it
+*/
+SWIGEXPORT int SWIG_init(lua_State* L)
+{
+  int i;
+  /* start with global table */
+  lua_pushvalue(L,LUA_GLOBALSINDEX);
+  /* SWIG's internal initalisation */
+  SWIG_InitializeModule((void*)L);
+  SWIG_PropagateClientData();
+  /* add a global fn */
+  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
+  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_equal);
+  /* begin the module (its a table with the same name as the module) */
+  SWIG_Lua_module_begin(L,SWIG_name);
+  /* add commands/functions */
+  for (i = 0; swig_commands[i].name; i++){
+    SWIG_Lua_module_add_function(L,swig_commands[i].name,swig_commands[i].func);
+  }
+  /* add variables */
+  for (i = 0; swig_variables[i].name; i++){
+    SWIG_Lua_module_add_variable(L,swig_variables[i].name,swig_variables[i].get,swig_variables[i].set);
+  }
+  /* set up base class pointers (the hierachy) */
+  for (i = 0; swig_types[i]; i++){
+    if (swig_types[i]->clientdata){
+      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
+    }
+  }
+  /* additional registration structs & classes in lua */
+  for (i = 0; swig_types[i]; i++){
+    if (swig_types[i]->clientdata){
+      SWIG_Lua_class_register(L,(swig_lua_class*)(swig_types[i]->clientdata));
+    }
+  }
+  /* constants */
+  SWIG_Lua_InstallConstants(L,swig_constants);
+  /* invoke user-specific initialization */
+  SWIG_init_user(L);
+  /* end module */
+  /* Note: We do not clean up the stack here (Lua will do this for us). At this
+     point, we have the globals table and out module table on the stack. Returning
+     one value makes the module table the result of the require command. */
+  return 1;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+
+const char* SWIG_LUACODE=
+  "";
+
+void SWIG_init_user(lua_State* L)
+{
+  /* exec Lua code if applicable */
+  SWIG_Lua_dostring(L,SWIG_LUACODE);
+}
+
diff --git a/proto/ospf/lsalib.c b/proto/ospf/lsalib.c
index bcf7bcd..f04a98f 100644
--- a/proto/ospf/lsalib.c
+++ b/proto/ospf/lsalib.c
@@ -12,10 +12,16 @@ void
 flush_lsa(struct top_hash_entry *en, struct proto_ospf *po)
 {
   struct proto *p = &po->proto;
+#ifdef ELSA_ENABLED
+  elsa_lsa elsa_lsa = elsa_platform_wrap_lsa(po, en);
+#endif /* ELSA_ENABLED */
 
   OSPF_TRACE(D_EVENTS,
 	     "Going to remove LSA Type: %04x, Id: %R, Rt: %R, Age: %u, Seqno: 0x%x",
 	     en->lsa.type, en->lsa.id, en->lsa.rt, en->lsa.age, en->lsa.sn);
+#ifdef ELSA_ENABLED
+  elsa_notify_deleting_lsa(po->elsa, elsa_lsa);
+#endif /* ELSA_ENABLED */
   s_rem_node(SNODE en);
   if (en->lsa_body != NULL)
     mb_free(en->lsa_body);
@@ -523,6 +529,9 @@ lsa_install_new(struct proto_ospf *po, struct ospf_lsa_header *lsa, u32 domain,
   /* LSA can be temporarrily, but body must be mb_allocated. */
   int change = 0;
   struct top_hash_entry *en;
+#ifdef ELSA_ENABLED
+  elsa_lsa elsa_lsa;
+#endif /* ELSA_ENABLED */
 
   if ((en = ospf_hash_find_header(po->gr, domain, lsa)) == NULL)
   {
@@ -555,7 +564,13 @@ lsa_install_new(struct proto_ospf *po, struct ospf_lsa_header *lsa, u32 domain,
   en->ini_age = en->lsa.age;
 
   if (change)
+  {
     schedule_rtcalc(po);
+#ifdef ELSA_ENABLED
+    elsa_lsa = elsa_platform_wrap_lsa(po, en);
+    elsa_notify_changed_lsa(po->elsa, elsa_lsa);
+#endif /* ELSA_ENABLED */
+  }
 
   return en;
 }
diff --git a/proto/ospf/lsupd.c b/proto/ospf/lsupd.c
index 16967a7..55600fc 100644
--- a/proto/ospf/lsupd.c
+++ b/proto/ospf/lsupd.c
@@ -8,6 +8,10 @@
 
 #include "ospf.h"
 
+#ifdef ELSA_ENABLED
+#include "elsa_internal.h"
+#include "elsa_platform.h"
+#endif /* ELSA_ENABLED */
 
 struct ospf_lsupd_packet
 {
@@ -50,7 +54,7 @@ static void ospf_dump_lsupd(struct proto *p, struct ospf_lsupd_packet *pkt)
     {
       if (offset > bound)
 	{
-	  log(L_TRACE "%s:     LSA      invalid", p->name);
+	  log(L_TRACE "%s:     LSA      invalid[1]", p->name);
 	  return;
 	}
 
@@ -61,7 +65,7 @@ static void ospf_dump_lsupd(struct proto *p, struct ospf_lsupd_packet *pkt)
 
       if (((lsalen % 4) != 0) || (lsalen <= sizeof(struct ospf_lsa_header)))
 	{
-	  log(L_TRACE "%s:     LSA      invalid", p->name);
+	  log(L_TRACE "%s:     LSA      invalid[2] - %d bytes", p->name, lsalen);
 	  return;
 	}
     }
@@ -109,7 +113,7 @@ unknown_lsa_type(struct ospf_lsa_header *lsa)
 
 int
 ospf_lsa_flooding_allowed(struct ospf_lsa_header *lsa, u32 domain, struct ospf_iface *ifa)
-{    
+{
   u32 scope = LSA_SCOPE(lsa);
 
   /* 4.5.2 (Case 2) */
@@ -143,7 +147,7 @@ ospf_lsa_flooding_allowed(struct ospf_lsa_header *lsa, u32 domain, struct ospf_i
  * ospf_lsupd_flood - send received or generated lsa to the neighbors
  * @po: OSPF protocol
  * @n: neighbor than sent this lsa (or NULL if generated)
- * @hn: LSA header followed by lsa body in network endianity (may be NULL) 
+ * @hn: LSA header followed by lsa body in network endianity (may be NULL)
  * @hh: LSA header in host endianity (must be filled)
  * @domain: domain of LSA (must be filled)
  * @rtl: add this LSA into retransmission list
@@ -378,10 +382,10 @@ ospf_lsupd_send_list(struct ospf_neighbor *n, list * l)
       if (en == NULL)
       {
 	/* Probably flushed LSA, this should not happen */
-	log(L_WARN "OSPF: LSA disappeared (Type: %04x, Id: %R, Rt: %R)", 
+	log(L_WARN "OSPF: LSA disappeared (Type: %04x, Id: %R, Rt: %R)",
 	    lsr->lsh.type, lsr->lsh.id, lsr->lsh.rt);
 	lsr = NODE_NEXT(lsr);
-	continue;			
+	continue;
       }
 
       len2 = len + en->lsa.length;
@@ -395,7 +399,7 @@ ospf_lsupd_send_list(struct ospf_neighbor *n, list * l)
 	if (len2 > ospf_pkt_bufsize(n->ifa))
 	{
 	  /* Cannot fit in a tx buffer, skip that */
-	  log(L_WARN "OSPF: LSA too large to send (Type: %04x, Id: %R, Rt: %R)", 
+	  log(L_WARN "OSPF: LSA too large to send (Type: %04x, Id: %R, Rt: %R)",
 	      lsr->lsh.type, lsr->lsh.id, lsr->lsh.rt);
 	  lsr = NODE_NEXT(lsr);
 	  continue;
@@ -432,6 +436,10 @@ ospf_lsupd_receive(struct ospf_packet *ps_i, struct ospf_iface *ifa,
   struct proto_ospf *po = ifa->oa->po;
   struct proto *p = &po->proto;
   unsigned int i, max, sendreq = 1;
+#ifdef ELSA_ENABLED
+  elsa_lsa dummy_elsa_lsa;
+  struct top_hash_entry dummy_the;
+#endif /* ELSA_ENABLED */
 
   unsigned int size = ntohs(ps_i->length);
   if (size < (sizeof(struct ospf_lsupd_packet) + sizeof(struct ospf_lsa_header)))
@@ -470,7 +478,7 @@ ospf_lsupd_receive(struct ospf_packet *ps_i, struct ospf_iface *ifa,
     struct ospf_lsa_header *lsa = (void *) (((u8 *) ps) + offset);
     unsigned int lsalen = ntohs(lsa->length);
     offset += lsalen;
- 
+
     if ((offset > size) || ((lsalen % 4) != 0) ||
 	(lsalen <= sizeof(struct ospf_lsa_header)))
     {
@@ -487,16 +495,18 @@ ospf_lsupd_receive(struct ospf_packet *ps_i, struct ospf_iface *ifa,
       continue;
     }
 
+    ntohlsah(lsa, &lsatmp);
+
 #ifdef OSPFv2
     /* pg 143 (2) */
-    if ((lsa->type == 0) || (lsa->type == 6) || (lsa->type > LSA_T_NSSA))
+    if ((lsatmp.type == 0) || (lsatmp.type == 6) || (lsatmp.type > LSA_T_NSSA))
     {
       log(L_WARN "Unknown LSA type from %I", n->ip);
       continue;
     }
 
     /* pg 143 (3) */
-    if ((lsa->type == LSA_T_EXT) && !oa_is_ext(ifa->oa))
+    if ((lsatmp.type == LSA_T_EXT) && !oa_is_ext(ifa->oa))
     {
       log(L_WARN "Received External LSA in stub area from %I", n->ip);
       continue;
@@ -514,13 +524,11 @@ ospf_lsupd_receive(struct ospf_packet *ps_i, struct ospf_iface *ifa,
     /* 4.5.1 (3) */
     if (scope == LSA_SCOPE_RES)
     {
-      log(L_WARN "Received LSA with invalid scope from %I", n->ip);
+      log(L_WARN "Received LSA with invalid scope from %I. LSA type is %X", n->ip, lsatmp.type);
       continue;
     }
 #endif
 
-    ntohlsah(lsa, &lsatmp);
-
     DBG("Update Type: %u ID: %R RT: %R, Sn: 0x%08x Age: %u, Sum: %u\n",
 	lsatmp.type, lsatmp.id, lsatmp.rt, lsatmp.sn, lsatmp.age, lsatmp.checksum);
 
@@ -580,6 +588,14 @@ ospf_lsupd_receive(struct ospf_packet *ps_i, struct ospf_iface *ifa,
 	OSPF_TRACE(D_EVENTS, "Received old self-originated LSA (Type: %04x, Id: %R, Rt: %R)",
 		   lsatmp.type, lsatmp.id, lsatmp.rt);
 
+#ifdef ELSA_ENABLED
+        /* Give ELSA first dibs at doing something with it.*/
+        dummy_the.lsa = lsatmp;
+        dummy_the.lsa_body = lsa + 1;
+        dummy_elsa_lsa = elsa_platform_wrap_lsa(po, &dummy_the);
+        elsa_notify_duplicate_lsa(po->elsa, dummy_elsa_lsa);
+#endif /* ELSA_ENABLED */
+
 	if (lsadb)
 	{
 	  OSPF_TRACE(D_EVENTS, "Reflooding new self-originated LSA with newer sequence number");
@@ -660,7 +676,7 @@ ospf_lsupd_receive(struct ospf_packet *ps_i, struct ospf_iface *ifa,
       {
 	log(L_WARN "Received invalid LSA from %I", n->ip);
 	mb_free(body);
-	continue;	
+	continue;
       }
 
       lsadb = lsa_install_new(po, &lsatmp, domain, body);
diff --git a/proto/ospf/ospf.c b/proto/ospf/ospf.c
index aa62da1..b3e62a3 100644
--- a/proto/ospf/ospf.c
+++ b/proto/ospf/ospf.c
@@ -8,7 +8,7 @@
 
 /**
  * DOC: Open Shortest Path First (OSPF)
- * 
+ *
  * The OSPF protocol is quite complicated and its complex implemenation is
  * split to many files. In |ospf.c|, you will find mainly the interface
  * for communication with the core (e.g., reconfiguration hooks, shutdown
@@ -72,7 +72,7 @@
  * (&proto_ospf->tick). It is responsible for aging and flushing of LSAs in
  * the database, for routing table calculaction and it call area_disp() of every
  * ospf_area.
- * 
+ *
  * The function area_disp() is
  * responsible for late originating of router LSA and network LSA
  * and for cleanup before routing table calculation process in
@@ -84,7 +84,7 @@
  * BIRD's OSPF implementation respects RFC2328 in every detail, but
  * some of internal algorithms do differ. The RFC recommends making a snapshot
  * of the link-state database when a new adjacency is forming and sending
- * the database description packets based on the information in this 
+ * the database description packets based on the information in this
  * snapshot. The database can be quite large in some networks, so
  * rather we walk through a &slist structure which allows us to
  * continue even if the actual LSA we were working with is deleted. New
@@ -190,7 +190,7 @@ ospf_area_remove(struct ospf_area *oa)
 
   /* We suppose that interfaces are already removed */
   ospf_flush_area(oa->po, oa->areaid);
- 
+
   fib_free(&oa->rtr);
   fib_free(&oa->net_fib);
   fib_free(&oa->enet_fib);
@@ -218,7 +218,7 @@ static struct ospf_iface *
 ospf_find_vlink(struct proto_ospf *po, u32 voa, u32 vid)
 {
   struct ospf_iface *ifa;
-  WALK_LIST(ifa, po->iface_list) 
+  WALK_LIST(ifa, po->iface_list)
     if ((ifa->type == OSPF_IT_VLINK) && (ifa->voa->areaid == voa) && (ifa->vid == vid))
       return ifa;
   return NULL;
@@ -232,6 +232,15 @@ ospf_start(struct proto *p)
   struct ospf_area_config *ac;
 
   po->router_id = proto_get_router_id(p->cf);
+  po->rid_is_random = proto_get_rid_is_random(p->cf);
+#ifdef OSPFv3
+  po->dridd = c->dridd;
+  if(!po->dridd && po->rid_is_random)
+    log(L_WARN "%s: Duplicate RID detection should be enabled when using a randomly generated RID", p->name);
+#ifdef ELSA_ENABLED
+  po->elsa = elsa_create(po);
+#endif /* ELSA_ENABLED */
+#endif /* OSPFv3 */
   po->rfc1583 = c->rfc1583;
   po->ebit = 0;
   po->ecmp = c->ecmp;
@@ -474,6 +483,11 @@ ospf_disp(timer * timer)
   WALK_LIST(oa, po->area_list)
     area_disp(oa);
 
+#ifdef ELSA_ENABLED
+  /* Call the ELSA dispatch callback */
+  elsa_dispatch(po->elsa);
+#endif /* ELSA_ENABLED */
+
   /* Age LSA DB */
   ospf_age(po);
 
@@ -734,6 +748,11 @@ ospf_reconfigure(struct proto *p, struct proto_config *c)
   if (old->abr != new->abr)
     return 0;
 
+#ifdef OSPFv3
+  if(po->dridd != new->dridd)
+    return 0; /* FIXME Can we reconfigure gracefully? */
+#endif
+
   po->ecmp = new->ecmp;
   po->tick = new->tick;
   po->disp_timer->recurrent = po->tick;
@@ -779,7 +798,7 @@ ospf_reconfigure(struct proto *p, struct proto_config *c)
       ospf_area_remove(oa);
 
   schedule_rtcalc(po);
-  
+
   return 1;
 }
 
@@ -995,14 +1014,14 @@ lsa_compare_for_state(const void *p1, const void *p2)
 
     return lsa1->sn - lsa2->sn;
   }
-  else 
+  else
   {
     if (lsa1->rt != lsa2->rt)
       return lsa1->rt - lsa2->rt;
 
     if (lsa1->type != lsa2->type)
       return lsa1->type - lsa2->type;
-  
+
     if (lsa1->id != lsa2->id)
       return lsa1->id - lsa2->id;
 
@@ -1010,7 +1029,7 @@ lsa_compare_for_state(const void *p1, const void *p2)
     if (px1 != px2)
       return px1 - px2;
 #endif
-  
+
     return lsa1->sn - lsa2->sn;
   }
 }
@@ -1028,7 +1047,7 @@ ext_compare_for_state(const void *p1, const void *p2)
 
   if (lsa1->id != lsa2->id)
     return lsa1->id - lsa2->id;
- 
+
   return lsa1->sn - lsa2->sn;
 }
 
@@ -1077,7 +1096,7 @@ show_lsa_router(struct proto_ospf *po, struct top_hash_entry *he, int first, int
 	struct ospf_lsa_header *net_lsa = &(net_he->lsa);
 	struct ospf_lsa_net *net_ln = net_he->lsa_body;
 
-	cli_msg(-1016, "\t\tnetwork %I/%d metric %u", 
+	cli_msg(-1016, "\t\tnetwork %I/%d metric %u",
 		ipa_and(ipa_from_u32(net_lsa->id), net_ln->netmask),
 		ipa_mklen(net_ln->netmask), rr[i].metric);
       }
@@ -1153,7 +1172,7 @@ show_lsa_sum_rt(struct top_hash_entry *he)
   // options = 0;
 #else /* OSPFv3 */
   struct ospf_lsa_sum_rt *ls = he->lsa_body;
-  dst_rid = ls->drid; 
+  dst_rid = ls->drid;
   // options = ls->options & OPTIONS_MASK;
 #endif
 
@@ -1191,7 +1210,7 @@ show_lsa_external(struct top_hash_entry *he)
   rt_fwaddr_valid = ext->metric & LSA_EXT_FBIT;
   if (rt_fwaddr_valid)
     buf = lsa_get_ipv6_addr(buf, &rt_fwaddr);
-  else 
+  else
     rt_fwaddr = IPA_NONE;
 
   if (ext->metric & LSA_EXT_TBIT)
@@ -1199,7 +1218,7 @@ show_lsa_external(struct top_hash_entry *he)
   else
     rt_tag = 0;
 #endif
-  
+
   if (rt_fwaddr_valid)
     bsprintf(str_via, " via %I", rt_fwaddr);
 
@@ -1262,7 +1281,7 @@ ospf_sh_state(struct proto *p, int verbose, int reachable)
     return;
   }
 
-  /* We store interesting area-scoped LSAs in array hea and 
+  /* We store interesting area-scoped LSAs in array hea and
      global-scoped (LSA_T_EXT) LSAs in array hex */
 
   struct top_hash_entry *hea[num];
@@ -1460,7 +1479,7 @@ lsa_compare_for_lsadb(const void *p1, const void *p2)
 
   if (lsa1->rt != lsa2->rt)
     return lsa1->rt - lsa2->rt;
-  
+
   if (lsa1->id != lsa2->id)
     return lsa1->id - lsa2->id;
 
@@ -1522,7 +1541,7 @@ ospf_sh_lsadb(struct lsadb_show_data *ld)
 
     if (ld->router && (lsa->rt != ld->router))
       continue;
-    
+
     if ((dscope != last_dscope) || (hea[i]->domain != last_domain))
     {
       cli_msg(-1017, "");
diff --git a/proto/ospf/ospf.h b/proto/ospf/ospf.h
index 3bffaf9..50c537c 100644
--- a/proto/ospf/ospf.h
+++ b/proto/ospf/ospf.h
@@ -48,6 +48,7 @@ do { if ((p->debug & D_PACKETS) || OSPF_FORCE_DEBUG) \
 #include "nest/locks.h"
 #include "conf/conf.h"
 #include "lib/string.h"
+#include "elsa.h"
 
 #define OSPF_PROTO 89
 
@@ -77,12 +78,22 @@ do { if ((p->debug & D_PACKETS) || OSPF_FORCE_DEBUG) \
 #define DEFAULT_ECMP_LIMIT 16
 #define DEFAULT_TRANSINT 40
 
+#ifdef OSPFv3
+#define DEFAULT_OSPFDRIDD 0  /* OSPF duplicate RID detection off by default */
+#define DEFAULT_OSPFPXASSIGNMENT 0 /* OSPF prefix assignment off by default */
+#endif
+
+#define LSA_AC_USP_MIN_PREFIX_LENGTH   8
+#define LSA_AC_USP_MAX_PREFIX_LENGTH   64
 
 struct ospf_config
 {
   struct proto_config c;
   unsigned tick;
   byte rfc1583;
+#ifdef OSPFv3
+  byte dridd;                   /* Is duplicate RID detection enabled? */
+#endif
   byte abr;
   int ecmp;
   list area_list;		/* list of struct ospf_area_config */
@@ -94,7 +105,7 @@ struct nbma_node
   node n;
   ip_addr ip;
   byte eligible;
-  byte found; 
+  byte found;
 };
 
 struct area_net_config
@@ -250,7 +261,7 @@ struct ospf_iface
 #define HELLOINT_D 10
 #define POLLINT_D 20
 #define DEADC_D 4
-#define WAIT_DMH 4		
+#define WAIT_DMH 4
   /* Value of Wait timer - not found it in RFC * - using 4*HELLO */
 
   struct top_hash_entry *net_lsa;	/* Originated network LSA */
@@ -776,6 +787,13 @@ struct proto_ospf
   int lsab_size, lsab_used;
   linpool *nhpool;		/* Linpool used for next hops computed in SPF */
   u32 router_id;
+  byte rid_is_random;           /* Whether or not RID was generated by a PRNG */
+#ifdef ELSA_ENABLED
+  elsa elsa;
+#endif /* ELSA_ENABLED */
+#ifdef OSPFv3
+  byte dridd;                   /* Is duplicate RID detection enabled? */
+#endif /* OSPFv3 */
 };
 
 struct ospf_iface_patt
diff --git a/proto/ospf/packet.c b/proto/ospf/packet.c
index 241a58f..03b3974 100644
--- a/proto/ospf/packet.c
+++ b/proto/ospf/packet.c
@@ -241,6 +241,20 @@ ospf_pkt_checkauth(struct ospf_neighbor *n, struct ospf_iface *ifa, struct ospf_
  
 #endif
 
+void rm_file_and_queue_async_config(const char *filename);
+
+void
+ospf_dridd_trigger(struct proto_ospf *po)
+{
+  /* FIXME: Rather scary move, this. Changing runtime
+   * configuration on the fly doesn't feel right. */
+  po->proto.cf->router_id = 0;
+  config->router_id = 0;
+
+  /* We need to pick new one, as we're numerically inferior. */
+  /* Get rid of the old stored router id and fire off re-configuration. */
+  rm_file_and_queue_async_config(config->rid_filename);
+}
 
 /**
  * ospf_rx_hook
@@ -419,6 +433,18 @@ ospf_rx_hook(sock *sk, int size)
   if (rid == po->router_id)
   {
     log(L_ERR "%s%I - received my own router ID!", mesg, sk->faddr);
+#ifdef OSPFv3
+    if (config->rid_is_random
+        && po->proto.cf->rid_is_random
+        && po->proto.cf->router_id == config->router_id
+        && po->dridd) {
+      log(L_ERR "Someone should reconfigure");
+      if (memcmp(&sk->faddr, &sk->laddr, sizeof(ip_addr)) > 0) {
+        log(L_ERR ".. and it's me!");
+        ospf_dridd_trigger(po);
+      }
+    }
+#endif /* OSPFv3 */
     return 1;
   }
 
diff --git a/run_elsa.sh b/run_elsa.sh
new file mode 100755
index 0000000..8ba68c0
--- /dev/null
+++ b/run_elsa.sh
@@ -0,0 +1,22 @@
+#!/bin/bash -e
+#-*-sh-*-
+#
+# $Id: run_elsa.sh $
+#
+# Author: Markus Stenberg <fingon@iki.fi>
+#
+# Copyright (c) 2012 cisco Systems, Inc.
+#
+# Created:       Thu Sep 27 12:51:34 2012 mstenber
+# Last modified: Wed Oct 24 13:38:28 2012 mstenber
+# Edit time:     4 min
+#
+
+# Propagate LUA_PATH so that required modules can be found more easily..
+
+if [ $# = 1 -a "$1" = "-d" ]
+then
+    sudo ENABLE_MST_DEBUG=1 LUA_PATH=$LUA_PATH valgrind ./bird -d -c bird6.conf.elsa
+else
+    sudo LUA_PATH=$LUA_PATH ./bird -d -c bird6.conf.elsa
+fi
diff --git a/sysdep/autoconf.h.in b/sysdep/autoconf.h.in
index ac6f7a8..436f8ad 100644
--- a/sysdep/autoconf.h.in
+++ b/sysdep/autoconf.h.in
@@ -63,3 +63,6 @@
 #undef HAVE_STDINT_H
 
 #define CONFIG_PATH ?
+
+/* Is external LSA support (~= Lua for OSPF) enabled? */
+#undef ELSA_ENABLED
diff --git a/sysdep/unix/Modules b/sysdep/unix/Modules
index 2c6514d..2b5450d 100644
--- a/sysdep/unix/Modules
+++ b/sysdep/unix/Modules
@@ -1,4 +1,5 @@
 log.c
+routerid.c
 main.c
 timer.h
 io.c
@@ -6,7 +7,6 @@ unix.h
 endian.h
 config.Y
 random.c
-
 krt.c
 krt.h
 krt.Y
diff --git a/sysdep/unix/config.Y b/sysdep/unix/config.Y
index 844f53d..caaea42 100644
--- a/sysdep/unix/config.Y
+++ b/sysdep/unix/config.Y
@@ -15,9 +15,10 @@ CF_DECLS
 
 CF_KEYWORDS(LOG, SYSLOG, ALL, DEBUG, TRACE, INFO, REMOTE, WARNING, ERROR, AUTH, FATAL, BUG, STDERR, SOFT)
 CF_KEYWORDS(TIMEFORMAT, ISO, SHORT, LONG, BASE, NAME)
+CF_KEYWORDS(REMEMBER)
 
 %type <i> log_mask log_mask_list log_cat
-%type <g> log_file
+%type <g> log_file 
 %type <t> cfg_name
 %type <tf> timeformat_which
 %type <t> syslog_name
@@ -71,6 +72,13 @@ log_cat:
  | BUG { $$ = L_BUG[0]; }
  ;
 
+CF_ADDTO(conf, remember_rid)
+
+remember_rid: ROUTER ID REMEMBER TEXT ';'
+ {
+  new_config->rid_filename = $4;
+ }
+;
 
 CF_ADDTO(conf, mrtdump_base)
 
diff --git a/sysdep/unix/io.c b/sysdep/unix/io.c
index f91b527..3045d50 100644
--- a/sysdep/unix/io.c
+++ b/sysdep/unix/io.c
@@ -1513,6 +1513,25 @@ sk_dump_all(void)
 #undef ERR
 #undef WARN
 
+static void
+init_random(void)
+{
+  int seed = now_real;
+  unsigned char buf[8];
+  FILE *f;
+
+  /* Try to get from /dev/urandom if available; if not, just use the
+   * seed as is. */
+  f = fopen("/dev/urandom", "r");
+  if (f)
+    {
+      (void)fread(buf, 1, 8, f);
+      fclose(f);
+      seed ^= *((int*)buf);
+    }
+  srandom(seed);
+}
+
 /*
  *	Main I/O Loop
  */
@@ -1520,6 +1539,15 @@ sk_dump_all(void)
 volatile int async_config_flag;		/* Asynchronous reconfiguration/dump scheduled */
 volatile int async_dump_flag;
 
+void rm_file_and_queue_async_config(const char *filename)
+{
+  if (filename) {
+    log(L_ERR "Unlinking %s", filename);
+    unlink(filename);
+  }
+  async_config_flag = 1;
+}
+
 void
 io_init(void)
 {
@@ -1530,7 +1558,7 @@ io_init(void)
   krt_io_init();
   init_times();
   update_times();
-  srandom((int) now_real);
+  init_random();
 }
 
 static int short_loops = 0;
diff --git a/sysdep/unix/routerid.c b/sysdep/unix/routerid.c
new file mode 100644
index 0000000..bd6905c
--- /dev/null
+++ b/sysdep/unix/routerid.c
@@ -0,0 +1,171 @@
+/*
+ *	BIRD Internet Routing Daemon -- Router ID storage
+ *
+ *      Author: Benjamin Paterson <benjamin@paterson.fr>
+ *
+ *      Copyright (c) 2012 cisco Systems, Inc.
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+/**
+ * DOC: Router ID file
+ * Essentially a stripped-down version of sysdep/unix/log.c.
+ *
+ * Allows reading/writing Router ID to a file.
+ * To write the RID to file, we use BIRD's bvsnprintf to easily
+ * format the RID and write it to a temporary buffer, then
+ * we use standard C library functions to write the buffer to file.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include "nest/bird.h"
+#include "lib/string.h"
+
+#define STD_RID_P_LENGTH 15
+#define RID_BUFFER_SIZE 100
+static char rid_buffer[RID_BUFFER_SIZE];
+static char *rid_buffer_pos;
+static int rid_buffer_remains;
+
+/**
+ * rid_reset - reset the rid buffer
+ *
+ * This function resets a rid buffer and discards buffered
+ * messages. Should be used before a preparing a rid entry with ridn().
+ */
+static void
+rid_reset(void)
+{
+  rid_buffer_pos = rid_buffer;
+  rid_buffer_remains = RID_BUFFER_SIZE;
+  rid_buffer[0] = 0;
+}
+
+/**
+ * rid_commit - commit a rid line
+ *
+ * This function writes a message prepared in the log buffer to the
+ * rid file (as specified in the configuration). The rid buffer is
+ * reset after that. The rid message is a full line, rid_commit()
+ * terminates it.
+ */
+static void
+rid_commit(void *f)
+{
+  if (f)
+  {
+    fputs(rid_buffer, f);
+    fputc('\n', f);
+    fflush(f);
+  }
+
+  rid_reset();
+}
+
+static void
+rid_print(const char *msg, va_list args)
+{
+  int i;
+
+  if (rid_buffer_remains == 0)
+    return;
+
+  i=bvsnprintf(rid_buffer_pos, rid_buffer_remains, msg, args);
+  if (i < 0)
+    {
+      bsprintf(rid_buffer + RID_BUFFER_SIZE - 100, " ... <too long>");
+      rid_buffer_remains = 0;
+      return;
+    }
+
+  rid_buffer_pos += i;
+  rid_buffer_remains -= i;
+}
+
+/**
+ * ridn - prepare a partial message in the rid buffer
+ * @msg: printf-like formatting string (without message class information)
+ *
+ * This function formats a message according to the format string @msg
+ * and adds it to the rid buffer. Messages in the rid buffer are
+ * written when the buffer is flushed using rid_commit() function. The
+ * message should not contain |\n|, rid_commit() also terminates a
+ * line.
+ */
+static void
+ridn(char *msg, ...)
+{
+  va_list args;
+
+  va_start(args, msg);
+  rid_print(msg, args);
+  va_end(args);
+}
+
+
+#ifndef IPV6
+
+/* On v6 side, this already exists; on v4, not (sigh) */
+
+static int
+ipv4_pton_u32(char *a, u32 *o)
+{
+  int i;
+  unsigned long int l;
+  u32 ia = 0;
+
+  i=4;
+  while (i--)
+    {
+      char *d, *c = strchr(a, '.');
+      if (!c != !i)
+	return 0;
+      l = strtoul(a, &d, 10);
+      if (d != c && *d || l > 255)
+	return 0;
+      ia = (ia << 8) | l;
+      if (c)
+	c++;
+      a = c;
+    }
+  *o = ia;
+  return 1;
+}
+
+#endif /* !IPV6 */
+
+
+u32 read_rid(const char *filename)
+{
+  u32 ret = 0;
+  char *pos;
+  char buf[STD_RID_P_LENGTH + 1];
+  FILE *f = fopen(filename, "r");
+
+  if (!f)
+    return 0;
+  if(fgets(buf, STD_RID_P_LENGTH + 1, f))
+  {
+    /* get rid of trailing newline */
+    if ((pos=strchr(buf, '\n')) != NULL)
+      *pos = '\0';
+
+    if(!ipv4_pton_u32(buf, &ret))
+      ret = 0;
+  }
+  fclose(f);
+  return ret;
+}
+
+void write_rid(const char *filename, u32 rid)
+{
+  FILE *f = fopen(filename, "w");
+
+  rid_reset();
+  ridn("%R", rid);
+  rid_commit(f);
+  fclose(f);
+}
diff --git a/tools/Rules.in b/tools/Rules.in
index fc06aeb..858021e 100644
--- a/tools/Rules.in
+++ b/tools/Rules.in
@@ -15,6 +15,7 @@ client-dirs := @CLIENT@
 client-dir-paths := $(client-dirs)
 doc-dirs := doc
 doc-dir-paths := $(doc-dirs)
+elsa-sources=@elsa_sources@
 
 all-dirs:=$(static-dirs) $(dynamic-dirs) $(client-dirs) $(doc-dirs)
 clean-dirs:=$(all-dirs) proto sysdep
diff --git a/tools/lua.m4 b/tools/lua.m4
new file mode 100644
index 0000000..3df2627
--- /dev/null
+++ b/tools/lua.m4
@@ -0,0 +1,196 @@
+# ===========================================================================
+#               http://www.nongnu.org/autoconf-archive/lua.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_WITH_LUA
+#   AX_LUA_VERSION (MIN-VERSION, [TOO-BIG-VERSION])
+#   AX_LUA_HEADERS
+#   AX_LUA_LIBS
+#   AX_LUA_LIB_VERSION (MIN-VERSION, [TOO-BIG-VERSION])
+#
+# DESCRIPTION
+#
+#   Detect Lua interpreter, headers and libraries, optionally enforcing a
+#   particular range of versions.
+#
+#   AX_WITH_LUA searches for Lua interpreter and defines LUA if found.
+#
+#   AX_LUA_VERSION checks that the version of Lua is at least MIN-VERSION
+#   and less than TOO-BIG-VERSION, if given.
+#
+#   AX_LUA_HEADERS searches for Lua headers and defines HAVE_LUA_H and
+#   HAVE_LUALIB_H if found, and defines LUA_INCLUDE to the preprocessor
+#   flags needed, if any.
+#
+#   AX_LUA_LIBS searches for Lua libraries and defines LUA_LIB if found.
+#
+#   AX_LUA_LIB_VERSION checks that the Lua libraries' version is at least
+#   MIN-VERSION, and less than TOO-BIG-VERSION, if given.
+#
+#   Versions are specified as three-digit integers whose first digit is the
+#   major version and last two are the minor version (the same format as
+#   LUA_VERSION_NUM in lua.h); e.g. 501 for Lua 5.1. The revision (e.g. the
+#   "3" in "5.1.3") is ignored.
+#
+#   The following options are added by these macros:
+#
+#     --with-lua-prefix=DIR     Lua files are in DIR.
+#     --with-lua-suffix=ARG     Lua binaries and library files are
+#                               suffixed with ARG.
+#     --with-lua-includes=DIR   Lua include files are in DIR.
+#     --with-lua-libraries=DIR  Lua library files are in DIR.
+#
+# LICENSE
+#
+#   Copyright (c) 2009 Reuben Thomas <rrt@sc3d.org>
+#   Copyright (c) 2009 Matthieu Moy <Matthieu.Moy@imag.fr>
+#   Copyright (c) 2009 Tom Payne <twpayne@gmail.com>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+dnl Helper function to declare extra options
+AC_DEFUN([_AX_LUA_OPTS],
+  [AC_ARG_WITH([lua-prefix],
+     [AS_HELP_STRING([--with-lua-prefix=DIR],
+        [Lua files are in DIR])])
+   AC_ARG_WITH([lua-suffix],
+     [AS_HELP_STRING([--with-lua-suffix=ARG],
+        [Lua binary and library files are suffixed with ARG])])
+   AC_ARG_WITH([lua-includes],
+     [AS_HELP_STRING([--with-lua-includes=DIR],
+        [Lua include files are in DIR])])
+   AC_ARG_WITH([lua-libraries],
+     [AS_HELP_STRING([--with-lua-libraries=DIR],
+        [Lua library files are in DIR])])])dnl
+
+AC_DEFUN([AX_WITH_LUA],
+  [_AX_LUA_OPTS
+  if test "x$with_lua_prefix" = x; then
+    lua_search_path="$PATH"
+  else
+    lua_search_path="$with_lua_prefix/bin"
+  fi
+  if test "x$LUA" = x; then
+    AC_PATH_PROG([LUA], [lua$with_lua_suffix], [], [$lua_search_path])
+  fi])dnl
+
+dnl Helper function to parse minimum & maximum versions
+AC_DEFUN([_AX_LUA_VERSIONS],
+  [lua_min_version=$1
+  lua_max_version=$2
+  if test "x$lua_min_version" = x; then
+    lua_min_version=0
+  fi
+  if test "x$lua_max_version" = x; then
+    lua_max_version=1000
+  fi])
+
+AC_DEFUN([AX_LUA_VERSION],
+  [_AX_LUA_OPTS
+  AC_MSG_CHECKING([Lua version is in range $1 <= v < $2])
+  _AX_LUA_VERSIONS($1, $2)
+  if test "x$LUA" != x; then
+    lua_text_version=$($LUA -v 2>&1 | head -n 1 | cut -d' ' -f2)
+    case $lua_text_version in
+    5.1*)
+      lua_version=501
+      ;;
+    5.0*)
+      lua_version=500
+      ;;
+    4.0*)
+      lua_version=400
+      ;;
+    *)
+      lua_version=-1
+      ;;
+    esac
+    if test $lua_version -ge "$lua_min_version" -a $lua_version -lt "$lua_max_version"; then
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+      AC_MSG_FAILURE([Lua version not in desired range.])
+    fi
+  else
+    AC_MSG_RESULT([no])
+    AC_MSG_FAILURE([Lua version not in desired range.])
+  fi])dnl
+
+AC_DEFUN([AX_LUA_HEADERS],
+  [_AX_LUA_OPTS
+  if test "x$with_lua_includes" != x; then
+    LUA_INCLUDE="-I$with_lua_includes"
+  elif test "x$with_lua_prefix" != x; then
+    LUA_INCLUDE="-I$with_lua_prefix/include"
+  fi
+  LUA_OLD_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS="$CPPFLAGS $LUA_INCLUDE"
+  AC_CHECK_HEADERS([lua.h lualib.h])
+  CPPFLAGS="$LUA_OLD_CPPFLAGS"])dnl
+
+AC_DEFUN([AX_LUA_LIBS],
+  [_AX_LUA_OPTS
+  if test "x$with_lua_libraries" != x; then
+    LUA_LIB="-L$with_lua_libraries"
+  elif test "x$with_lua_prefix" != x; then
+    LUA_LIB="-L$with_lua_prefix/lib"
+  fi
+  AC_CHECK_LIB([m], [exp], [lua_extra_libs="$lua_extra_libs -lm"], [])
+  AC_CHECK_LIB([dl], [dlopen], [lua_extra_libs="$lua_extra_libs -ldl"], [])
+  AC_CHECK_LIB([lua$with_lua_suffix],
+    [lua_call],
+    [LUA_LIB="$LUA_LIB -llua$with_lua_suffix $lua_extra_libs"],
+    [],
+    [$LUA_LIB $lua_extra_libs])])dnl
+
+AC_DEFUN([AX_LUA_LIB_VERSION],
+  [_AX_LUA_OPTS
+  AC_MSG_CHECKING([liblua version is in range $1 <= v < $2])
+  _AX_LUA_VERSIONS($1, $2)
+  LUA_OLD_LIBS="$LIBS"
+  LIBS="$LIBS $LUA_LIB"
+  LUA_OLD_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS="$CPPFLAGS $LUA_INCLUDE"
+  AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <lua.h>
+#include <stdlib.h>
+#include <stdio.h>
+int main()
+{
+  printf("(found %s, %d)... ", LUA_VERSION, LUA_VERSION_NUM);
+  if (LUA_VERSION_NUM >= $lua_min_version && LUA_VERSION_NUM < $lua_max_version)
+    exit(EXIT_SUCCESS);
+  exit(EXIT_FAILURE);
+}
+]])],
+  [AC_MSG_RESULT([yes])],
+  [AC_MSG_RESULT([no])
+  AC_MSG_FAILURE([Lua libraries version not in desired range])])
+  LIBS="$LUA_OLD_LIBS"
+  CPPFLAGS="$LUA_OLD_CPPFLAGS"])dnl
