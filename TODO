-*- outline -*-

* MDNS - Things to do

** Synthesize reverse PTRs on demand? Or just filter them?

Probably synthesizing is bad idea, as it is possible that same IP address
maps to multiple names, and host can choose which name to use. Due to that,
just filtering the e.g. linklocals is probably sensible.

** Do math on scalability/feasibility of different approaches

*** site-local multicast

 Traits
 - add expensive (spams whole network)
 - maintenance NONE
 - queries expensive (spams whole network)

*** active probing (ours)

 Traits
 - add new => announced globally (OSPF, link churn)
 - maintenance => just local resources probed every now and then
 - queries ~free

*** relay-ish (Shwetha?)

 ? (I don't understand it well enough)

*** DNS-SD => mdns (Cheshire hybrid)

 - scary question, though - when query is 'done'?

 - typically requires manual configuration(?) or co-operation between
   routers(??) to get browse paths right

  - in homenet context, we could synthesize 'ask all links' case easily
    enough from the OSPF ASPs

 Traits
 - add cheap (local op)
 - maintenance NONE
 - queries expensive

*** DNS-SD + DNS-SD update

 - problem: liveliness of data

 Traits
 - add cheap (local op)
 - maintenance NONE
 - queries moderately expensive (given shitload of zones; however, can have
   less zones than in DNS-SD => mdns case => probably

*** Conclusions

What it boils down to is the ratio of different ops - add / maintenance /
query. Impossible say what is the mix in a typical home network..

* MDNS - Nice to have

** Write patch set for luasocket changes for Diego

* Not-exactly-our software - Bugs to fix

** ISC dhclient

- duid not consistent (sigh) => interesting issues when rebooting routers..

(encountered at IETF86)

(- low t1/t2 values => problems )

- near boot time, both ISC dhclient and dhcpd work strangely - can be
  related to kernel version, the sockets won't get ADVERTISEs that someone
  sends to us, but the situation persists until we restart daemon at some
  later point

** BIRD - doesn't handle too big LSAs gracefully

.. blows up due to rx-buf used for sending being smaller than what is being
stuffed down there. 

Workaround: use 'rx buffer large' in config files.

** BIRD - OSPFv3

lsalib.c: 86 => what happens of time moves backwards?

nothing good happens if time moves much forwards, _either_. *sigh*

* PA - Bugs to fix

** Propagated DHCP lifetimes not reflected correctly

** Enable spaces in domain search strings

Right now, the shell scripts that deal with skvtool don't escape them
appropriately => things probably blow up horribly. Is this a real problem,
though?

** BIRD - dridd p#2

Duplicate rid detected correctly even if router connected to ~self. But
problem is, it won't behave consistently (=form neigh's with other
routers), as the packets coming with different LL address using same RID on
same link confuse the other party. 

** rhf bit flaky

- sometimes eth0, sometimes eth1 too.. depending on which if is up. correct
  approach is to check _all_ interfaces that are configured, regardless of
  addresses present (right now we seed it with IPv6)

* PA - Things to do

** Try to identify memory leaks, if any

** Add prefix option support

Backward compatible approach: Define 'USP/ASP with options' TLVs. Use those
AND normal ones, until normal support no longer needed => remove normal
support altogether.

- Discuss with Arkko et al what form they should take

- add code to encode/decode new format ones (and do it in parallel with old
  format)

(Current hack of options-in-jsonblob is bit iffy)


** update README's

.. few things not correct, I think

- add memory usage caveats

** Cleanup BIRD changes

- whitespace?
+ works with, without lua? with ipv6, without ipv6?
 - should automate these tests

** Recursive routing

use ULA's for border nodes in the routing table on non-border nodes

=> less need to refresh the information

.. if not available, fall back to non-ULA lookup

.. each router can announce it's ULA in the infamous JSONBLOB
:--p

** On-link detection

(or smart bridging? could bridge if no routers detected on link..)

** Save assignments

** Code review the code

Comments to self

- use of 'class' as name for class name is bit misleading
 - but 'name' might be too popular(?)

- accessors for getting class object, superclass objects would be nice

 - could use some sort of ~singleton to save classname=>class,
   class=>superclass relations?

- changed semantics so that no implicit copying happening almost anywhere
  => caller responsibility. only way to ensure high performance?

- added validity_sync utility class, which handles a collection's
  validity. it has methods for both setting and clearing validity of
  everything within (and it works with arrays, maps, multimaps)

- at some point could try to clean up the class inheritance mess -
  especially tostring handling is worryingly opaque

- could try to optimize map:count, array:count, array:is with some play
  around metatables (is_array flag, perhaps member count too?)

- how to deal with >255 nodes on IPv4 subnet? 

TODO codereview
- ipv6s (bit too much spaghetti, perhaps?)
- ~l331 pa.lua+

** split mst.lua

** Comprehensively test PA alg (2/2)

- think more corner cases to test
 - _large_ topologies should still converge (and they seem to; should set
   up VMs to make sure, though, instead of just the stress test)
 
+ try to see if we can do again the DHCPv4 bug
 + some sort of mutating topology testcase? which runs long time?
   .. make sure every now and then that the design assertions hold,
   e.g. one IP address per interface per device, one prefix per link per USP
 [ done, stress/elsa_pa_stress.lua ]

* Things to do if I have time (hah)

** Use netlink instead of 'ip' command to interact with IP addresses

Plan: 

- Wrap a library (e.g. http://www.infradead.org/~tgr/libnl/) with SWIG
 - Lua -> C provided by SWIG
 - C -> Lua 

- Write higher level abstraction library on top of that

.. probably couple of days of coding, all in all, and yet another package
dependency/even more bloated hnet-core (as we need to compile C
extensions). Therefore only 'nice-to-have', not mandatory, yet..

Unit testing using this needs to be considered too; the high level
abstraction API has to be simple, so it can be mocked without too much
pain, as in unit testing we trust..

** More effective handling of multimap memory usage

If just 1 entry, shouldn't use list, but instead just single entry.

** Dynamic border handling (for real)

.. actually configure firewall etc based on detection results.

- run OSPF on all interfaces [trivial, we do that now too]

- run PD on all interfaces [we do this now too, but could do it more
  efficiently]

- only OSPF (/nothing) = interior
- only PD = exterior
- rest = mixed, but I'd prefer to treat them as exterior for firewalling
  purposes

** Determine if two interfaces are bridged somehow

(two ports, same bridged network => need only one address/...?)

** Design own routing protocol? :---p

- OSPF insanely chatty

- assumption should be: 

 - link is ~constant 

- IF no traffic whatsoever, make sure of bidir reachability (but can trust
  e.g. RAs?)

- with traffic, routing protocol shouldn't need to chat _much_

- and chat should be just trickle-based 'life still same for you?
  brilliant, mate.'

- subtree synchronization => e.g. using hash trees, with few (or many)
  roundtrips depending on how large portions of tree are checked at once

- subtree updates can just send change deltas => no need for synchronization

.. these assumptions work for wired. how about wireless?

- _have_ to be more proactive about verifying people are still on link

- packet loss more of a concern?


** Optimize PA alg

*** Profile it (no premature optimizations)

*** Make sure computational complexity of all ops is minimal

pa.asp lookups - now use rid as key

- iid natural index - used in prefix assignment algorithm (run_if_usp)

 ! hmmh. iid nonunique though, and rid IS primary key now that I figured
 that rid+iid is the unique key (took me a month but .. :-p) perhaps rid is
 ok?

- prefix should be also index (binary prefix, probably) => conflict resolution
  constant time (check_asp_conflicts)

- rid only relevant for finding own ASPs - we could store them separately
  anyway? (get_local_asp_values)

- usp => asp needed - or some other way (find_assigned)
  given #usp small, not necessary?

pa.usp lookups - now use rid as key

- containing prefix lookup cannot be optimized (or probably not worth it,
  #usp is small)

*** PA alg - phase 2 - enable incremential mode 

step 1: LSAs changed, IFs changed (? - mostly LSAs in a network should be
stable)

*** PA alg - phase 3 - enable even more incremential mode 

step 2: individual LSA change notifications

(IF changes are hopefully rare enough..)

just get provided with LSA updates




** Document architecture better

- at least what moves, where

- which modules exist

- ...



** DNS with split horizon based on domains

- multihomed, may want to use e.g. cisco.com server X, and for rest Y

** Border detection - DHCPv6 PD integration

Somehow keep probing that DHCPv6 server is present on link.. that may
require luasocket w/ v6?

!!! fairly broken that we have to use SLAAC to get default route on
    interface; also making sure it stays valid is awkward.. and should make
    sure it's not one of the OSPF talking nodes somehow (...)

I suppose we can play with ND to make sure it stays there (and therefore
DHCPv6 solicit flooding isn't really neccessary?)

*** Which DHCPv6 PD to use?

- ISC has huge dependencies and is big

- dnsmasq too integrated with dnsmasq

 <2k LoC

- udhcp in busybox seems bit broken

 <2k LoC

.. just implement the state machine in SMC, make it a public reference, 


** 6rd sunsetting

right now probably won't work correctly due to ignoring preferences; but
does anyone care :p

.. to do: write testcase which has 6rd+native with same assigned prefix,
and make sure result is sane

** Memory usage optimization

One LUA in system is probably acceptable memory hit; two+ might not be. If
so, have to consider how to slim the count to 1..

Currently ~2MB per process (pm.lua, bird6-elsa), which results in 4MB
memory overheard compared to system with 0 Lua in it.

** Try to get avahi fixed

It joins ipv6 linklocal multicast groups with non-linklocal addresses, and
also uses those as default source addresses when talking with other
hosts. That's just broken.


** Improve SKV <> OSPF sync for MDNS

[2] define new AC TLV, gzipped-jsonblob, and squeeze in the RR there? (much
more efficient in terms of space usage, but even harder to push through the
IETF process)

[3] correct approach would be to define e.g. MDNS-CACHE-RR TLV, and put
  those in there? no name compression though => relatively large entries =>
  perhaps MDNS-CACHE-STATE TLV, which contains list of DNS RR's with shared
  name compression?

- name compression + binary =~ half size
- gzip = quarter


*** Consult Arkko/OT about shared problem

- problem: what if LSA size (2^16-1 = 64k) is exceeded?

- answer: need to do multiple lsid's worth?

