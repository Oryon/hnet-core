-*- outline -*-

* Bugs to fix
* Things to do

** DHCPv6 PD integration (static WAN)

- just set up the variable using skvtool.lua, and we're golden?

** Multihoming support

- requires next-hop finding (from rt.c / process_prefixes can take some
  hints, as it calculates the IPv6 prefix reachability based on the
  advertising router ids - we should do something similar, router id if the
  USP => calculate next hop for that)

 - add API to ELSA to get routes to specific router id's => win(?)
   (could also include it in the rid callbacks, _if_ it's cheap to produce;
    however, I doubt it's free, and as number of egress routers is less
   than number of home routers, doing them all is inefficient)
   
- PM should configure skv-published USP+if+nexthop pairs to 'ip rule' table

'ospf-usp' key will contain stuff for ip rule table
 {{prefix=usp-prefix, ifname=ifname, nh=next-hop}, ...}

** Comprehensively test PA alg (2/2)

- think more corner cases to test

* Things to do if I have time (hah)
** Minimize the BIRD changes (now there's still too many leftovers)
** Refactor callbacks etc. to use tables more

more than one argument => chance to get order wrong
(with one, well..)

** Optimize PA alg

*** Profile it (no premature optimizations)

*** Make sure computational complexity of all ops is minimal

pa.asp lookups - now use rid as key

- iid natural index - used in prefix assignment algorithm (run_if_usp)

- prefix should be also index (binary prefix, probably) => conflict resolution
  constant time (check_asp_conflicts)

- rid only relevant for finding own ASPs - we could store them separately
  anyway? (get_local_asp_values)

- usp => asp needed - or some other way (find_assigned)
  given #usp small, not necessary?

pa.usp lookups - now use rid as key

- containing prefix lookup cannot be optimized (or probably not worth it,
  #usp is small)


*** PA alg - enable incremential mode 

step 1: LSAs changed, IFs changed

*** PA alg - enable even more incremential mode 

step 2: individual LSA change notifications

(IF changes are hopefully rare enough..)

just get provided with LSA updates


** Document architecture better

- at least what moves, where

- which modules exist

- ...


** IPv4 support

What does it _mean_? RFC 1918 space allocation, pick _one_ random prefix,
NAT outbound stuff.

Just use 10.Y.X.0

Y = random number picked by whoever provides the route (v4-USP message)

X = assigned subnet # (if someone has more than 255 networks in their home
running v4, oh well; we can alternatively use Y space also for X if that's
better model, but this one works with CGN that uses 10.* space, with 1/256
chance of failure .. )

How we detect upstream connectivity?

Simple - run DHCPv4 client _on each interface_, listen for anything that's
NOT 10.Y.* that is available.

=> what's needed:

- DHCPv4 client per interface on box, which publishes results to skv pd-v4.IF
- slightly modified variant of PA alg
- PM needs to configure
 - NAT rule 
 - DHCPv4 server per non-pd-v4.IF 

==> ULA-like algorithm


** Naming support?

- should provide stateless DHCPv6 with DNS info at least (gathered from all
  providers?)

** DHCPv6 PD integration (border detection stuff, ick)

Somehow keep probing that DHCPv6 server is present on link.. that may
require luasocket w/ v6?

!!! fairly broken that we have to use SLAAC to get default route on
    interface; also making sure it stays valid is awkward.. and should make
    sure it's not one of the OSPF talking nodes somehow (...)

I suppose we can play with ND to make sure it stays there (and therefore
DHCPv6 solicit flooding isn't really neccessary?)

*** Which DHCPv6 PD to use?

- ISC has huge dependencies and is big

- dnsmasq too integrated with dnsmasq

 <2k LoC

- udhcp in busybox seems bit broken

 <2k LoC

.. just implement the state machine in SMC, make it a public reference, 


** Write ~Pythonic key handling to mst. data structures

- requires ~Pythonia equality function


- API-wise, should look like current one

- except, accept tables and other arbitrary structures as keys and compare
  them 'correctly' (now, has to be same table instance for it to work,
  which is unfortunate)

* Improvements that affect only performance

** Aggregate the updates somehow

- either glob things to bigger blobs (e.g. 'ospf-pa' key) [possibly
  inefficient in terms of transmitted data]

or

- send updates via 0-timeout in event loop in single big packets [requires
  bit smarter handling code]

* Done (8.10.+)

** Comprehensively test PA alg

- corner cases (sigh)
 - running out of addrs
 - different conflict situations?

- fixed iid-is-global assumption I made.. (*sigh*)

** PA alg features

*** ULA generation

*** HW addr stuff, duplicate router detection

*** detect RID changes

if OSPF changes RID, we should update it in elsa_pa (and pa)


* Done (1.10.+)

** Make command line tool to inject USPs

skvtool.lua!

** Integrate PA alg, OSPF-ELSA codec, SKV, and rest 

*** pm module (probably should run elsewhere than in OSPF?) [done 05/10]

 maintain local if state according to 'ospf-lap' / 'ospf-usp' changes

 - mutate radvd.conf

 - ip address add/remove

 ospf-usp can be used to control which prefixes we care about, but
 alternative approach is to give control of _all_ assignments to this.

*** wrapper around elsa_pa for elsa.lua [done 04/10]

*** elsa_pa module [done 03/10]

 OSPF => PA

 - provides 'client' interface to pa using elsa + codec

 => ASP, USP information from ELSA + codec decoded OSPFv3 LSAs
 => if information from ELSA

 + data from skv [USP]

 PA => OSPF
 - originates AC payloads using 'codec' and pa local ASP state
 + data from skv [USP]

 PA => PM
 - use skv to publish state
 + local interface info [LAP]
 + USP info

SKV content:

'pd.<if>' results of DHCPv6 prefix delegation for a single interface
 format: {{prefix[, valid-lifetime]}, ...}

'iflist' should be a list of interfaces that have been seen _at some point_
(this can be updated by scripts, or ospf)

'ospf-lap' key will contain state local hosts should care about
 {{ifname=ifname, prefix=prefix}, ...} for every non-depracated prefix

** Figure why enabling debug breaks tests

** Write PA alg prototype in Lua

** Converted to strict.lua

* Done (24.9.+)

** Implement simple (len, binary-blob) low level i/o for SKV

** Implement JSON wrapping on top of that

** Write handlers for reading/writing JSON as needed

** Add whole 'listener' abstraction, deal with it (client+server)

 - {add,remove}_change_observer in skv

** SWIG ELSA + provide for Lua running inside BIRD

** Write AC LSA en-decode functionality in LUA
