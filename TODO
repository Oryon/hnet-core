-*- outline -*-

* Bugs to fix

** Try not to allocate stuff on if's that are bridged

(two ports, same bridged network => need only one address/...?)

** BIRD - OSPFv3

lsalib.c: 86 => what happens of time moves backwards?

** findings

- windows failed horribly
- Lorenzo's Linux had same features - why?

** fun hack

- instead of calculating the nh all the time

 - make route to the BR ip => can be ~static! (win-win, kernel does the
   ugly bits)

** interesting point

- default src+default dst = used for address selection
=> we don't have global connectivity on homenet without!

** at some point someone 'stole' USP prefix ownership

=> routes broke

= wtf ??

** identify why eth1 is only working PD interface on HW

.. pd client on eth0.* does not work the same way (has some assumptions
about IP aliases? started by hand=works, started at boot=does not work)

** write testsuite which tests time changes

- at least the *pa.lua should not be confused by time jumps
  (or it should recover from them)

.. potential source of router #3(/6) hangup

it cleared it's state and never recovered; it is also possible that somehow
the pm process does something bad, but seems unlikely as all these fields
are sourced from BIRD and are set to sensible-looking values

root@inner:~# skvtool -l
ospf-rid=24336807
ospf-v4-dns={}
ospf-v4-dns-search={}
ospf-dns={}
ospf-iflist={"eth0.2", "eth0.3", "eth0.4", "eth1", "eth0.1"}
disable-pa-eth0="1"
ospf-dns-search={}
ospf-usp={}
ospf-lap={{address="10.24.33.23/32", ifname="eth0.4", prefix="10.24.33.0/24"}, {ifname="eth0.4", prefix="fc60:574d:6f60:3468::/64"}}
root@inner:~# 

** rhf bit flaky

- sometimes eth0, sometimes eth1 too.. depending on which if is up. correct
  approach is to check _all_ interfaces that are configured, regardless of
  addresses present (right now we seed it with IPv6)

* Things to do

** Recursive routing

use ULA's for border nodes in the routing table on non-border nodes

=> less need to refresh the information

.. if not available, fall back to non-ULA lookup

.. each router can announce it's ULA in the infamous JSONBLOB
:--p

** On-link detection

(or smart bridging? could bridge if no routers detected on link..)

** Save assignments

** Code review the code

Comments to self

- use of 'class' as name for class name is bit misleading
 - but 'name' might be too popular(?)

- accessors for getting class object, superclass objects would be nice

 - could use some sort of ~singleton to save classname=>class,
   class=>superclass relations?

- changed semantics so that no implicit copying happening almost anywhere
  => caller responsibility. only way to ensure high performance?

- added validity_sync utility class, which handles a collection's
  validity. it has methods for both setting and clearing validity of
  everything within (and it works with arrays, maps, multimaps)

- at some point could try to clean up the class inheritance mess -
  especially tostring handling is worryingly opaque

- could try to optimize map:count, array:count, array:is with some play
  around metatables (is_array flag, perhaps member count too?)

- how to deal with >255 nodes on IPv4 subnet? 

TODO codereview
- ipv6s (bit too much spaghetti, perhaps?)
- ~l331 pa.lua+

** split mst.lua

** Demo topology?

[ - IETF v6? (/x?) ]

ISP-CPE-N
- HE tunnel (/48)
- DHCPv6 PD server (delegating /56s from /48)

via DHCP, provide Google DNS server address

https://developers.google.com/speed/public-dns/docs/using

8.8.8.8
8.8.4.4

2001:4860:4860::8888
2001:4860:4860::8844

** Comprehensively test PA alg (2/2)

- think more corner cases to test
 - _large_ topologies should still converge
 
- try to see if we can do again the DHCPv4 bug
 - some sort of mutating topology testcase? which runs long time?
   .. make sure every now and then that the design assertions hold,
   e.g. one IP address per interface per device, one prefix per link per USP

* Things to do if I have time (hah)

** Design own routing protocol? :---p

- OSPF insanely chatty

- assumption should be: 

 - link is ~constant 

- IF no traffic whatsoever, make sure of bidir reachability (but can trust
  e.g. RAs?)

- with traffic, routing protocol shouldn't need to chat _much_

- and chat should be just trickle-based 'life still same for you?
  brilliant, mate.'

- subtree synchronization => e.g. using hash trees, with few (or many)
  roundtrips depending on how large portions of tree are checked at once

- subtree updates can just send change deltas => no need for synchronization

.. these assumptions work for wired. how about wireless?

- _have_ to be more proactive about verifying people are still on link

- packet loss more of a concern?


** Convert the hnet Lua stuff to a single package-formatted thing

** Package hnet package for OpenWRT

- also have dependency on bird6-elsa, do all the relevant init scripts etc
=> ~plug-n-play

** Cleanup BIRD changes

- whitespace?
+ works with, without lua? with ipv6, without ipv6?
 - should automate these tests

** Optimize memory usage

- there's ~300kb of static stuff that isn't really needed in the LSA/etc

.. but that's peanuts, 32MB router image ran out of memory when running
primitive topology(!).. by default ~40MB used. OMG :p

** Optimize PA alg

*** Profile it (no premature optimizations)

*** Make sure computational complexity of all ops is minimal

pa.asp lookups - now use rid as key

- iid natural index - used in prefix assignment algorithm (run_if_usp)

 ! hmmh. iid nonunique though, and rid IS primary key now that I figured
 that rid+iid is the unique key (took me a month but .. :-p) perhaps rid is
 ok?

- prefix should be also index (binary prefix, probably) => conflict resolution
  constant time (check_asp_conflicts)

- rid only relevant for finding own ASPs - we could store them separately
  anyway? (get_local_asp_values)

- usp => asp needed - or some other way (find_assigned)
  given #usp small, not necessary?

pa.usp lookups - now use rid as key

- containing prefix lookup cannot be optimized (or probably not worth it,
  #usp is small)

*** PA alg - phase 2 - enable incremential mode 

step 1: LSAs changed, IFs changed (? - mostly LSAs in a network should be
stable)

*** PA alg - phase 3 - enable even more incremential mode 

step 2: individual LSA change notifications

(IF changes are hopefully rare enough..)

just get provided with LSA updates




** Document architecture better

- at least what moves, where

- which modules exist

- ...



** DNS with split horizon based on domains

- multihomed, may want to use e.g. cisco.com server X, and for rest Y

** Border detection - DHCPv6 PD integration

Somehow keep probing that DHCPv6 server is present on link.. that may
require luasocket w/ v6?

!!! fairly broken that we have to use SLAAC to get default route on
    interface; also making sure it stays valid is awkward.. and should make
    sure it's not one of the OSPF talking nodes somehow (...)

I suppose we can play with ND to make sure it stays there (and therefore
DHCPv6 solicit flooding isn't really neccessary?)

*** Which DHCPv6 PD to use?

- ISC has huge dependencies and is big

- dnsmasq too integrated with dnsmasq

 <2k LoC

- udhcp in busybox seems bit broken

 <2k LoC

.. just implement the state machine in SMC, make it a public reference, 


** 6rd sunsetting

right now probably won't work correctly due to ignoring preferences; but
does anyone care :p

.. to do: write testcase which has 6rd+native with same assigned prefix,
and make sure result is sane

* Done (5.11.+)

** Next-hop management in pm.lua

DHCPv6 case - the next-hop router _may_ change, for various reasons, and
now the internet connectivity stays down until DHCPv6 PD lease expires

.. provided by real RA support

** Real RA support

options:

a) use kernel

 accept_ra 2 [ do RA accepting even when router ]
 accept_ra_defrtr 1
 accept_ra_pinfo 0 [ we don't really want normal address ]

and then..

- can get it from there either as part of in-Bird stuff

OR

+ using e.g. ip -6 route checking for default routes

 - bit less effective, but much more robust?

! stuff needs to be enabled/disabled per-border detection, as otherwise
  things break horribly (

.. as there's delay to this, we can use rdisc6 for _first approximation_
(and to speed up the initial part). Polling kernel will be painful :p

b) do it in userland

- listening to RA is easy

- NUD painful

** bugs

*** pd nh disappears at times at renew?

- the rdisc6 stuff should be more robust, or we should probe more actively
  ( the latter + correct state machine = win, in long term)

.. fixed by real RA use

*** dhcpd

- for some reason #4 box dropped dhcpv4 support

 - configs look ok-ish

 - but no response to e.g. DHCPv4

 .. hmm.

eth0.2, eth0.3 same IPv4 subnet

ospf-lap={
{address="10.105.164.9/32", ifname="eth0.2", owner=true,
prefix="10.105.164.0/24"}, 
{ifname="eth0.2", owner=true, prefix="2001:470:e178:bd95::/64"}, 
{ifname="eth0.2", owner=true, prefix="2001:470:dd33:b0f9::/64"}, 
{ifname="eth0.2", owner=true, prefix="fcf7:7f30:29b2:6215::/64"}, 
{ifname="eth0.2", prefix="2001:470:e178:bdb1::/64"}, 
{address="10.174.208.51/32", ifname="eth0.2", prefix="10.174.208.0/24"}, 
{ifname="eth0.2", prefix="2001:470:dd33:b074::/64"}, 
{ifname="eth0.2", prefix="fcf7:7f30:29b2:7739::/64"}, 
{address="10.43.92.52/32", ifname="eth0.3", owner=true,
prefix="10.43.92.0/24"}, 
{ifname="eth0.3", owner=true, prefix="2001:470:e178:bd38::/64"}, 
{ifname="eth0.3", owner=true, prefix="2001:470:dd33:b07b::/64"}, 
{ifname="eth0.3", owner=true, prefix="fcf7:7f30:29b2:dda8::/64"}, 
{ifname="eth0.3", prefix="2001:470:e178:bdb1::/64"}, 
{address="10.174.208.49/32", ifname="eth0.3", prefix="10.174.208.0/24"}, 
{ifname="eth0.3", prefix="2001:470:dd33:b074::/64"}, 
{ifname="eth0.3", prefix="fcf7:7f30:29b2:7739::/64"}, 
{address="10.215.93.16/32", ifname="eth0.4", owner=true,
prefix="10.215.93.0/24"}, 
{ifname="eth0.4", owner=true, prefix="2001:470:e178:bd0a::/64"}, 
{ifname="eth0.4", owner=true, prefix="2001:470:dd33:b022::/64"}, 
{ifname="eth0.4", owner=true, prefix="fcf7:7f30:29b2:714a::/64"}, 
{address="10.135.129.54/32", ifname="eth1", prefix="10.135.129.0/24"}, 
{ifname="eth1", prefix="2001:470:e178:bdb2::/64"}, 
{ifname="eth1", prefix="2001:470:dd33:b03c::/64"}, 
{ifname="eth1", prefix="fcf7:7f30:29b2:5a2f::/64"}, 
{address="10.18.247.16/32", ifname="eth0.1", owner=true,
prefix="10.18.247.0/24"}, 
{ifname="eth0.1", owner=true, prefix="2001:470:e178:bd71::/64"}, 
{ifname="eth0.1", owner=true, prefix="2001:470:dd33:b089::/64"}, 
{ifname="eth0.1", owner=true, prefix="fcf7:7f30:29b2:de06::/64"}}

8: eth0.2@eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP 
    inet 10.174.208.51/24 brd 10.174.208.255 scope global eth0.2
9: eth0.3@eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP 
    inet 10.174.208.49/24 brd 10.174.208.255 scope global eth0.3

! WTH are _two_ address'es doing out there?
! one owner, one not owner
 - one relic from past but not cleaned up correctly?

.. let's compare it to what we have on another router

ospf-lap={
{address="10.174.208.52/32", ifname="eth0.2", prefix="10.174.208.0/24"}, 
{ifname="eth0.2", prefix="2001:470:dd33:b074::/64"}, 
{ifname="eth0.2", prefix="fcf7:7f30:29b2:7739::/64"}, 
{ifname="eth0.2", prefix="2001:470:e178:bdb1::/64"}, 
{address="10.132.137.43/32", ifname="eth0.2", owner=true,
prefix="10.132.137.0/24"}, 
{ifname="eth0.2", owner=true, prefix="2001:470:dd33:b09e::/64"}, 
{ifname="eth0.2", owner=true, prefix="fcf7:7f30:29b2:35d4::/64"}, 
{ifname="eth0.2", owner=true, prefix="2001:470:e178:bd27::/64"}, 
{address="10.3.175.60/32", ifname="eth0.3", owner=true,
prefix="10.3.175.0/24"}, 
{ifname="eth0.3", owner=true, prefix="2001:470:dd33:b036::/64"}, 
{ifname="eth0.3", owner=true, prefix="fcf7:7f30:29b2:a511::/64"}, 
{ifname="eth0.3", owner=true, prefix="2001:470:e178:bdc8::/64"}, 
{address="10.100.200.50/32", ifname="eth0.4", owner=true,
prefix="10.100.200.0/24"}, 
{ifname="eth0.4", owner=true, prefix="2001:470:dd33:b04c::/64"}, 
{ifname="eth0.4", owner=true, prefix="fcf7:7f30:29b2:ce3d::/64"}, 
{ifname="eth0.4", owner=true, prefix="2001:470:e178:bddd::/64"}, 
{address="10.18.247.12/32", ifname="eth1", prefix="10.18.247.0/24"}, 
{ifname="eth1", prefix="2001:470:dd33:b089::/64"}, 
{ifname="eth1", prefix="fcf7:7f30:29b2:de06::/64"}, 
{ifname="eth1", prefix="2001:470:e178:bd71::/64"}, 
{address="10.215.93.3/32", ifname="eth0.1", prefix="10.215.93.0/24"}, 
{ifname="eth0.1", prefix="2001:470:dd33:b022::/64"}, 
{ifname="eth0.1", prefix="fcf7:7f30:29b2:714a::/64"}, 
{ifname="eth0.1", prefix="2001:470:e178:bd0a::/64"}
}

! router 5 seems to have also bonus one

=> fixed ssloop timeout handling to be bit better (hopefully), and also
added assertion that we never punt this on to pm.lua again (things will
just blow up on elsa_pa skv export, if we find here again)


** should offer very, very short leases until we have DNS parameters?

** route to router (nh calc) still bugging

+ solution: just set up always subnet also on the ISP-facing side, and
route towards that using standard BIRD Nest API.. works, but not insanely
elegant.

* Done (29.10.+)

** Package lua-md5 for openwrt

it's prohibitively slow with sha1.. *sigh*

** skv gets to infinite loop at some point?

- or somehow gets same transaction multiple times

.. there was rather horrid bug in jsoncodec :p

** Convert to use ULA always? (and add option to disable it too)

- pa.disable_always_ula

** Why address assignments are not constant?

+ should make sure nothing uses non-hash-seeded randomness

 .. as it turns out, we used rid as base, and in real world routers with
 zero conf _start_ out with random rid => it's somewhat inferior to
 starting with HWF-based one, as in that case the router starts with same
 prefix regardless of what state it happens to be in..

 [ do iid's stay constant? or should we use actually ifnames? hmm. ]

** Why some test timeouts

** Non-/8 divisible prefix length support

- not hard math, but should do it; also should avoid raw-binary (without
  bit length) as datastore anywhere, as ascii+prefix length or
  binary+prefix length are lossless data wise, but raw-binary isn't

** Write ~Pythonic key handling to mst. data structures

- requires ~Pythonia equality function


- API-wise, should look like current one

- except, accept tables and other arbitrary structures as keys and compare
  them 'correctly' (now, has to be same table instance for it to work,
  which is unfortunate)


** Improve DNS support

- provide _stateless_ DHCPv6 and RA DNS server + search domain information

! ISC DHCP P.O.S. does not do stateless stuff at all - needs some state to
  work. Clearly not the option we want to support => at some point have to
  write minimal DHCPv6 server (.. among other things. *sigh*)

.. and stateful stuff is horrible, e.g.

Interface eth1 matches multiple shared networks

(can only have only subnet per interface, it seems)


! rdnssd does not support search domain (even in it's latest
  incarnation). even more stuff I could contirbute to, perhaps..

** Compile for Buffalo, get it working there

- write scripts (using Python telnetlib) to produce ~desired router config
  from scratch

Plan B: Change OpenWRT installation s.t. luasocket is default, and so is
patches BIRD

~howto

.. need also iproute2 package ..
+ homenet-feed (feeds.conf add)
+ prefer it (scripts/feeds install -p homenet)
+ install bird6

=> by default included

- scripts 
 - fire up both bird6 + pm with valid config
 - fire up ISC DHCPv6 PD client with appropriate script

=> zero-conf(!)

What's needed to get the getup on real Buffalo as opposed to OpenWRT?

+ image with binaries
 + ISC DHCP (v4, v6)
 + Babel
 + bird6-elsa

+ files/ with configuration
 also the Lua stuff + shell script helpers 
 (these should move to a separate package at some point)

+ local_setup.sh which prepares ground

+ rc.local

** Why radvd doesn't stay up? Or does someone kill it?

- seems like it wasn't happy about nonexistent configs at least => making
  sure we have valid config seems to have alleviated the problem a bit

- PD <> hnet integration is again bit questionable; we _really_ need NH
  maintenance

! /var non-symlink = big issue on owrt, it seems..

** IPv4 support

What does it _mean_? RFC 1918 space allocation, pick _one_ random prefix,
NAT outbound stuff. Try to avoid detectable conflicts.

*** Who originates v4-ULA?

- whoever has highest combination of (configured, rid)

=> configured overrides rid, rid used as tie-breaker

- if not configured, ULA-like behavior

 - try for unique-ish based on v4-upstream's (SHOULD)

  [ can publish the upstream addresses to make the choice sensible ]

**** DIFFERENCE to ULA

- we want to have this setup regardless of existing v4 connectivity

- BUT we want to know about potential conflicts in the DHCP'd addresses

*** What payloads we need?

v4-ULA

- the internal address we use

v4-upstream (SHOULD)

- egress links' assigned addresses

(used to make ULA separate from them, if possible)

v4-ASP

- like v6 ASP

v4-AA

- assigned addresses (to the routers)

*** USP scheme

Just use 10.Y.X.0, or 192.168.X.0

Y = random number picked by whoever provides the route (v4-ULA message)

X = assigned subnet # (if someone has more than 255 networks in their home
running v4, oh well; we can alternatively use Y space also for X if that's
better model, but this one works with CGN that uses 10.* space, with 1/256
chance of failure .. )

*** Crazy idea 2:

Instead of having dedicated v4 payloads, use v6 ones!

/120 ASP
/108-114 USP

and ::ffff:ip base

Pro: 
+ same data structure
+ same algorithms (for most part)

Con: 
- have to deal with variable prefix width
- 3 types of USPs (now 'only' two, ULA and global-ish)

*** How we detect upstream connectivity? [if we want it dynamically anyway]

Simple - run DHCPv4 client _on each interface_, listen for anything that's
NOT from v4-ULA.

=> what's needed:

- DHCPv4 client per interface on box, which publishes results to skv pd-v4.IF
- slightly modified variant of PA alg
- PM needs to configure
 - NAT rule 
 - DHCPv4 server per non-pd-v4.IF 

*** Crazy idea 3

Routers need v4 addresses to function; we can allocate them using the same
'rid trumps' algorithm, from e.g. first /6 of the block (leaving the rest
for DHCPv4 - 64 routers, 192 hosts per subnet)

.. 'owner' responsible for running DHCPv4 server

.. could even sync DHCPv4 state across the 'cloud' for redundancy, but why
bother? DNS discovery?

** Make elsa.lua location configuration option

Hardcoding is bad, mmkay - and if not present, disable the whole thing

** Secondary demo features

~secondary - IPv4

 - need to have IPv4 routing protocol (BIRD?)

 - BIRD not necessarily optimal? 

** IPv4 setup

pieces:

- dhclient with IPv4 _on interfaces with PD
  => potentially detect outside edges of the network

  [ started manually by PM ]

  [ or can be manually configured too, e.g. v4-iflist; pd interfaces are
    just a default ]

  [[ can be also statically configured ]]

- OSPFv3 changes (~pa.lua)

 - v4-ext (external prefixes)

 [ just toss 'em in JSON for the time being.. ]

 ! for the time being skipped

 + v4-usp (configured, prefix) combo => chosen from the router with highest
   (configured, rid) tuple

 [ can be probably normal USP with ~ULA-like behavior, with bit different
 bit length, and extra constraint of it not being in v4-ext lists if not
 manually configured? ]

 ! for the time being, no 'configured' flag

 + v4-asp - assigned from v4-usp

 [ can be probably normal ASP, with different bit length ]

 - v4-asa - assigned addresses on links to routers (rid-based duplicate
   detection/elimination)

 [ JSON contains list 'v4-asa' for a router ]

  addresses have to be globally unique => which link they're attached on
  doesn't matter (but usp-asp mechanism should result in the asp being only
  on single switched network)

- local address assignment on interfaces (IPv4); based on OSPFv3 [ in PM ]

=> changes

+ pm* (v4 address assignment, dhclient running)
 + run dhclient for v4
+ elsa_pa (SKV export, changes to originated LSA)
+ pa (most of the changes)
+ ipv6s (v4-encoding stuff)



* Done (22.10.+)

** Race condition between DHCPv6 PD request, and RADVD setup for ULA

.. if RADVD is set up, we may get our _own_ address back

=> added temporary fix to ip-util, which will use -m option to deal with
that case, and filters own addresses out

(correct solution would be to do ND periodically, and offload the next hop
maintenance to pm.lua)

** Demo features?

+ DHCPv6 PD running on all interfaces

 => ~wan if receive something

+ DNS

 + learn from DHCPv6 PD

 + RA, stateless DHCPv6

- ULA all the time?

(MarkT's keen to test it; I'm still not sure..)

** Aggregate the updates

- _handle_ costly updates via 0-timeout in event loop in single big packets
  [requires bit smarter handling code]

** Add DNS support

+ store them in OSPF?

+ provide out with RA (Linux doesn't really use, I suppose) and DHCPv6
  stateless (trivial config file addition)



** PA alg - phase 1 - invoke only if necessary

pa:should_run() => call pa:run() only if needed
=> major CPU savings in the infra ;) (at least with logging enabled)

** Cleanup BIRD changes

+ works with, without lua? with ipv6, without ipv6?

** Minimize the BIRD changes (now there's still too many leftovers)

* Done (15.10.+)


** Fix 'flakiness'

~500 second+X interval when the connectivity goes down

theory: RA refresh interval _is_ 600; based on looking at logs, 

.. probably addressed it. still, something better is desirable?

use old ifname+nh until new one available; don't remove old if new one not
available!

[approach: don't use kernel RA/default routes => seems to work?]

** Multihoming support

+ requires next-hop finding (from rt.c / process_prefixes can take some
  hints, as it calculates the IPv6 prefix reachability based on the
  advertising router ids - we should do something similar, router id of the
  USP => calculate next hop for that)

 rt.c/ri_install_rt probably more relevant

  ip_addr addr = ipa_from_rid(rid);
  ort *r = (ort *)fib_get(&ospf_area->rtr, &addr, MAX_PREFIX_LENGTH);
  .. fib_find better - returns NULL if non existent
  .. look at r->n->nhs

 [ using topology.[ch] + the leftover ->nhs from the rt.c SPF calculation;
 officially supposed not to work, but it seems to ]


 + add API to elsai to get routes to specific router id's => win(?), and
 use it to produce next hop + ifname to iterate_rid callbacks
   
+ PM should configure skv-published USP+if+nexthop pairs to 'ip rule' table

'ospf-usp' key will contain stuff for ip rule table
 {{prefix=usp-prefix, ifname=ifname, nh=next-hop}, ...}

** Bird crashes sometimes randomly when reloading (...)

Last messages in log:

18-10-2012 09:19:30 <TRACE> MyOSPF: HELLO packet sent via eth2
18-10-2012 09:19:30 <TRACE> MyOSPF: State changed to flush
18-10-2012 09:19:30 <TRACE> MyOSPF: Going to remove LSA Type: 2009, Id: 0.0.0.4, Rt: 97.123.206.230, Age: 3600, Seqno: 0x80000002

.. tried to fix it by making reload occur like it does in rest of the code,
that is, in root of event loop.

[fixed?]

** 6RD integration (static WAN)

- just setup the variable using skvtool.lua based on DHCPv6 result

- probably needs gw address 

[multiprovider stuff needs some extra action]

** Refactor callbacks etc. to use tables more

more than one argument => chance to get order wrong (with one, well..)

* Done (8.10.+)

** DHCPv6 PD integration (static WAN)

- just set up the variable using skvtool.lua, and we're golden?

[multiprovider stuff needs some extra action]

** Comprehensively test PA alg

- corner cases (sigh)
 - running out of addrs
 - different conflict situations?

- fixed iid-is-global assumption I made.. (*sigh*)

** PA alg features

*** ULA generation

*** HW addr stuff, duplicate router detection

*** detect RID changes

if OSPF changes RID, we should update it in elsa_pa (and pa)


* Done (1.10.+)

** Make command line tool to inject USPs

skvtool.lua!

** Integrate PA alg, OSPF-ELSA codec, SKV, and rest 

*** pm module (probably should run elsewhere than in OSPF?) [done 05/10]

 maintain local if state according to 'ospf-lap' / 'ospf-usp' changes

 - mutate radvd.conf

 - ip address add/remove

 ospf-usp can be used to control which prefixes we care about, but
 alternative approach is to give control of _all_ assignments to this.

*** wrapper around elsa_pa for elsa.lua [done 04/10]

*** elsa_pa module [done 03/10]

 OSPF => PA

 - provides 'client' interface to pa using elsa + codec

 => ASP, USP information from ELSA + codec decoded OSPFv3 LSAs
 => if information from ELSA

 + data from skv [USP]

 PA => OSPF
 - originates AC payloads using 'codec' and pa local ASP state
 + data from skv [USP]

 PA => PM
 - use skv to publish state
 + local interface info [LAP]
 + USP info

SKV content:

'pd.<if>' results of DHCPv6 prefix delegation for a single interface
 format: {{prefix[, valid-lifetime]}, ...}

'iflist' should be a list of interfaces that have been seen _at some point_
(this can be updated by scripts, or ospf)

'ospf-lap' key will contain state local hosts should care about
 {{ifname=ifname, prefix=prefix}, ...} for every non-depracated prefix

** Figure why enabling debug breaks tests

** Write PA alg prototype in Lua

** Converted to strict.lua

* Done (24.9.+)

** Implement simple (len, binary-blob) low level i/o for SKV

** Implement JSON wrapping on top of that

** Write handlers for reading/writing JSON as needed

** Add whole 'listener' abstraction, deal with it (client+server)

 - {add,remove}_change_observer in skv

** SWIG ELSA + provide for Lua running inside BIRD

** Write AC LSA en-decode functionality in LUA
