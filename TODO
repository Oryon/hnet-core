-*- outline -*-

* Bugs to fix

** BIRD - dridd p#2

Duplicate rid detected correctly even if router connected to ~self. But
problem is, it won't behave consistently (=form neigh's with other
routers), as the packets coming with different LL address using same RID on
same link confuse the other party. 

** BIRD - OSPFv3

lsalib.c: 86 => what happens of time moves backwards?

nothing good happens if time moves much forwards, _either_. *sigh*

** rhf bit flaky

- sometimes eth0, sometimes eth1 too.. depending on which if is up. correct
  approach is to check _all_ interfaces that are configured, regardless of
  addresses present (right now we seed it with IPv6)

* Things to do

** refactor skv fields to be more sensible

- some sort of self-describing nested-table approach

- skvtool may need some sort of better data structure manipulation tools?
  (add/remove to list?)

** Cleanup BIRD changes

- whitespace?
+ works with, without lua? with ipv6, without ipv6?
 - should automate these tests

** Recursive routing

use ULA's for border nodes in the routing table on non-border nodes

=> less need to refresh the information

.. if not available, fall back to non-ULA lookup

.. each router can announce it's ULA in the infamous JSONBLOB
:--p

** On-link detection

(or smart bridging? could bridge if no routers detected on link..)

** Save assignments

** Code review the code

Comments to self

- use of 'class' as name for class name is bit misleading
 - but 'name' might be too popular(?)

- accessors for getting class object, superclass objects would be nice

 - could use some sort of ~singleton to save classname=>class,
   class=>superclass relations?

- changed semantics so that no implicit copying happening almost anywhere
  => caller responsibility. only way to ensure high performance?

- added validity_sync utility class, which handles a collection's
  validity. it has methods for both setting and clearing validity of
  everything within (and it works with arrays, maps, multimaps)

- at some point could try to clean up the class inheritance mess -
  especially tostring handling is worryingly opaque

- could try to optimize map:count, array:count, array:is with some play
  around metatables (is_array flag, perhaps member count too?)

- how to deal with >255 nodes on IPv4 subnet? 

TODO codereview
- ipv6s (bit too much spaghetti, perhaps?)
- ~l331 pa.lua+

** split mst.lua

** Comprehensively test PA alg (2/2)

- think more corner cases to test
 - _large_ topologies should still converge (and they seem to; should set
   up VMs to make sure, though, instead of just the stress test)
 
+ try to see if we can do again the DHCPv4 bug
 + some sort of mutating topology testcase? which runs long time?
   .. make sure every now and then that the design assertions hold,
   e.g. one IP address per interface per device, one prefix per link per USP
 [ done, stress/elsa_pa_stress.lua ]

* Things to do if I have time (hah)

** Dynamic border handling (for real)

.. actually configure firewall etc based on detection results.

- run OSPF on all interfaces [trivial, we do that now too]

- run PD on all interfaces [we do this now too, but could do it more
  efficiently]

- only OSPF (/nothing) = interior
- only PD = exterior
- rest = mixed, but I'd prefer to treat them as exterior for firewalling
  purposes

** Determine if two interfaces are bridged somehow

(two ports, same bridged network => need only one address/...?)

** Design own routing protocol? :---p

- OSPF insanely chatty

- assumption should be: 

 - link is ~constant 

- IF no traffic whatsoever, make sure of bidir reachability (but can trust
  e.g. RAs?)

- with traffic, routing protocol shouldn't need to chat _much_

- and chat should be just trickle-based 'life still same for you?
  brilliant, mate.'

- subtree synchronization => e.g. using hash trees, with few (or many)
  roundtrips depending on how large portions of tree are checked at once

- subtree updates can just send change deltas => no need for synchronization

.. these assumptions work for wired. how about wireless?

- _have_ to be more proactive about verifying people are still on link

- packet loss more of a concern?


** Optimize PA alg

*** Profile it (no premature optimizations)

*** Make sure computational complexity of all ops is minimal

pa.asp lookups - now use rid as key

- iid natural index - used in prefix assignment algorithm (run_if_usp)

 ! hmmh. iid nonunique though, and rid IS primary key now that I figured
 that rid+iid is the unique key (took me a month but .. :-p) perhaps rid is
 ok?

- prefix should be also index (binary prefix, probably) => conflict resolution
  constant time (check_asp_conflicts)

- rid only relevant for finding own ASPs - we could store them separately
  anyway? (get_local_asp_values)

- usp => asp needed - or some other way (find_assigned)
  given #usp small, not necessary?

pa.usp lookups - now use rid as key

- containing prefix lookup cannot be optimized (or probably not worth it,
  #usp is small)

*** PA alg - phase 2 - enable incremential mode 

step 1: LSAs changed, IFs changed (? - mostly LSAs in a network should be
stable)

*** PA alg - phase 3 - enable even more incremential mode 

step 2: individual LSA change notifications

(IF changes are hopefully rare enough..)

just get provided with LSA updates




** Document architecture better

- at least what moves, where

- which modules exist

- ...



** DNS with split horizon based on domains

- multihomed, may want to use e.g. cisco.com server X, and for rest Y

** Border detection - DHCPv6 PD integration

Somehow keep probing that DHCPv6 server is present on link.. that may
require luasocket w/ v6?

!!! fairly broken that we have to use SLAAC to get default route on
    interface; also making sure it stays valid is awkward.. and should make
    sure it's not one of the OSPF talking nodes somehow (...)

I suppose we can play with ND to make sure it stays there (and therefore
DHCPv6 solicit flooding isn't really neccessary?)

*** Which DHCPv6 PD to use?

- ISC has huge dependencies and is big

- dnsmasq too integrated with dnsmasq

 <2k LoC

- udhcp in busybox seems bit broken

 <2k LoC

.. just implement the state machine in SMC, make it a public reference, 


** 6rd sunsetting

right now probably won't work correctly due to ignoring preferences; but
does anyone care :p

.. to do: write testcase which has 6rd+native with same assigned prefix,
and make sure result is sane

