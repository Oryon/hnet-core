-*- outline -*-

* MDNS - Things to do

** Try to get avahi fixed

It joins ipv6 linklocal multicast groups with non-linklocal addresses, and
also uses those as default source addresses when talking with other
hosts. That's just broken.

** Make codebase it work with non-linklocal addresses too

Key idea:

- maintain ~every now and then updated local IPv6 address table (code
already exists in linux_if, although it isn't pretty as it just uses shell
commands and does not use the real API)

 - elegant way would be to figure OS level API, abstract it to Lua,
   etc.. but that sounds just like major hassle

- for any inbound packet, either it is
  <fe80:...>%<ifname>
  => just use <addr> + <ifname>
 
  or

  <addr>

  in case of <addr>, look up <ifname> with matching prefix, and use that

=> B.I.Y.U.

This stuff covers a number of SHOULDs in the draft.

** Implement SKV <> OSPF sync

+ [1] just toss the cache entries to jsonblob (good short-term solution,
least efficient encoding, hardest to push through)

(JSON_MDNS_KEY used to store the skv's MDNS_OWN_SKV_KEY, which should
contain minimalist rr tables with {name=, rtype=, rdata=}..)

[2] define new AC TLV, gzipped-jsonblob, and squeeze in the RR there? (much
more efficient in terms of space usage, but even harder to push through the
IETF process)

[3] correct approach would be to define e.g. MDNS-CACHE-RR TLV, and put
  those in there? no name compression though => relatively large entries =>
  perhaps MDNS-CACHE-STATE TLV, which contains list of DNS RR's with shared
  name compression?

*** Consult Arkko/OT about shared problem

- problem: what if LSA size (2^16-1 = 64k) is exceeded?

- answer: need to do multiple lsid's worth?

** Create stand-alone daemon

+ mdns_ospf + skv

+ elsa_pa: SKV<=>OSPF publishing

+ ssloop for event handling (mainly, to deal with skv, and to handle
  inbound UDP packets; ssloop in general is done, but UDP support may
  require small changes, as currently ssloop operates on TCP only)

+ Luasocket (w/ IPv6 multicast join/leave support) for socket handling
 + need to integrate to OpenWRT build process own version
  + replace the built-in luasocket with e.g. hnet-luasocket package (...)
 - need to build(?) it for NetKit
 - need to get Diego to accept it

+ mdns.lua
 + tie together above bits => one coherent whole (TODO: mcast join/leave)

** Add some sort of 'initial state fetcher' 

.. when becoming owner of an interface, should proactively query (with qu
set on?) for services, and then instances of those services..

i.e. q {'_services', '_dns-sd', '_udp', 'local'}
.. and then q for everything within!

(we _may_ also keep a list of services we've ever heard about, and include
those explicitly in initial query; that's also perfectly valid option, but
should be just used as backup solution)

* PA - Bugs to fix

** BIRD - dridd p#2

Duplicate rid detected correctly even if router connected to ~self. But
problem is, it won't behave consistently (=form neigh's with other
routers), as the packets coming with different LL address using same RID on
same link confuse the other party. 

** BIRD - OSPFv3

lsalib.c: 86 => what happens of time moves backwards?

nothing good happens if time moves much forwards, _either_. *sigh*

** rhf bit flaky

- sometimes eth0, sometimes eth1 too.. depending on which if is up. correct
  approach is to check _all_ interfaces that are configured, regardless of
  addresses present (right now we seed it with IPv6)


* PA - Things to do

** Add support for multiple prefixes per interface

(or more generically, implement the ~real data structure handling, the raw
skv primitives seem too .. primitive?)

** Add prefix option support

Backward compatible approach: Define 'USP/ASP with options' TLVs. Use those
AND normal ones, until normal support no longer needed => remove normal
support altogether.

- Discuss with Arkko et al what form they should take

- add code to encode/decode new format ones (and do it in parallel with old
  format)


** update README's

.. few things not correct, I think

- add memory usage caveats

** refactor skv fields to be more sensible

- some sort of self-describing nested-table approach

- skvtool may need some sort of better data structure manipulation tools?
  (add/remove to list?)

** Cleanup BIRD changes

- whitespace?
+ works with, without lua? with ipv6, without ipv6?
 - should automate these tests

** Recursive routing

use ULA's for border nodes in the routing table on non-border nodes

=> less need to refresh the information

.. if not available, fall back to non-ULA lookup

.. each router can announce it's ULA in the infamous JSONBLOB
:--p

** On-link detection

(or smart bridging? could bridge if no routers detected on link..)

** Save assignments

** Code review the code

Comments to self

- use of 'class' as name for class name is bit misleading
 - but 'name' might be too popular(?)

- accessors for getting class object, superclass objects would be nice

 - could use some sort of ~singleton to save classname=>class,
   class=>superclass relations?

- changed semantics so that no implicit copying happening almost anywhere
  => caller responsibility. only way to ensure high performance?

- added validity_sync utility class, which handles a collection's
  validity. it has methods for both setting and clearing validity of
  everything within (and it works with arrays, maps, multimaps)

- at some point could try to clean up the class inheritance mess -
  especially tostring handling is worryingly opaque

- could try to optimize map:count, array:count, array:is with some play
  around metatables (is_array flag, perhaps member count too?)

- how to deal with >255 nodes on IPv4 subnet? 

TODO codereview
- ipv6s (bit too much spaghetti, perhaps?)
- ~l331 pa.lua+

** split mst.lua

** Comprehensively test PA alg (2/2)

- think more corner cases to test
 - _large_ topologies should still converge (and they seem to; should set
   up VMs to make sure, though, instead of just the stress test)
 
+ try to see if we can do again the DHCPv4 bug
 + some sort of mutating topology testcase? which runs long time?
   .. make sure every now and then that the design assertions hold,
   e.g. one IP address per interface per device, one prefix per link per USP
 [ done, stress/elsa_pa_stress.lua ]

* Things to do if I have time (hah)

** More effective handling of multimap memory usage

If just 1 entry, shouldn't use list, but instead just single entry.

** Dynamic border handling (for real)

.. actually configure firewall etc based on detection results.

- run OSPF on all interfaces [trivial, we do that now too]

- run PD on all interfaces [we do this now too, but could do it more
  efficiently]

- only OSPF (/nothing) = interior
- only PD = exterior
- rest = mixed, but I'd prefer to treat them as exterior for firewalling
  purposes

** Determine if two interfaces are bridged somehow

(two ports, same bridged network => need only one address/...?)

** Design own routing protocol? :---p

- OSPF insanely chatty

- assumption should be: 

 - link is ~constant 

- IF no traffic whatsoever, make sure of bidir reachability (but can trust
  e.g. RAs?)

- with traffic, routing protocol shouldn't need to chat _much_

- and chat should be just trickle-based 'life still same for you?
  brilliant, mate.'

- subtree synchronization => e.g. using hash trees, with few (or many)
  roundtrips depending on how large portions of tree are checked at once

- subtree updates can just send change deltas => no need for synchronization

.. these assumptions work for wired. how about wireless?

- _have_ to be more proactive about verifying people are still on link

- packet loss more of a concern?


** Optimize PA alg

*** Profile it (no premature optimizations)

*** Make sure computational complexity of all ops is minimal

pa.asp lookups - now use rid as key

- iid natural index - used in prefix assignment algorithm (run_if_usp)

 ! hmmh. iid nonunique though, and rid IS primary key now that I figured
 that rid+iid is the unique key (took me a month but .. :-p) perhaps rid is
 ok?

- prefix should be also index (binary prefix, probably) => conflict resolution
  constant time (check_asp_conflicts)

- rid only relevant for finding own ASPs - we could store them separately
  anyway? (get_local_asp_values)

- usp => asp needed - or some other way (find_assigned)
  given #usp small, not necessary?

pa.usp lookups - now use rid as key

- containing prefix lookup cannot be optimized (or probably not worth it,
  #usp is small)

*** PA alg - phase 2 - enable incremential mode 

step 1: LSAs changed, IFs changed (? - mostly LSAs in a network should be
stable)

*** PA alg - phase 3 - enable even more incremential mode 

step 2: individual LSA change notifications

(IF changes are hopefully rare enough..)

just get provided with LSA updates




** Document architecture better

- at least what moves, where

- which modules exist

- ...



** DNS with split horizon based on domains

- multihomed, may want to use e.g. cisco.com server X, and for rest Y

** Border detection - DHCPv6 PD integration

Somehow keep probing that DHCPv6 server is present on link.. that may
require luasocket w/ v6?

!!! fairly broken that we have to use SLAAC to get default route on
    interface; also making sure it stays valid is awkward.. and should make
    sure it's not one of the OSPF talking nodes somehow (...)

I suppose we can play with ND to make sure it stays there (and therefore
DHCPv6 solicit flooding isn't really neccessary?)

*** Which DHCPv6 PD to use?

- ISC has huge dependencies and is big

- dnsmasq too integrated with dnsmasq

 <2k LoC

- udhcp in busybox seems bit broken

 <2k LoC

.. just implement the state machine in SMC, make it a public reference, 


** 6rd sunsetting

right now probably won't work correctly due to ignoring preferences; but
does anyone care :p

.. to do: write testcase which has 6rd+native with same assigned prefix,
and make sure result is sane

** Memory usage optimization

One LUA in system is probably acceptable memory hit; two+ might not be. If
so, have to consider how to slim the count to 1..

Currently ~2MB per process (pm.lua, bird6-elsa), which results in 4MB
memory overheard compared to system with 0 Lua in it.

